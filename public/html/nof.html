<!DOCTYPE html>
<html lang="en">
<head>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Experiment Title -->
    <title>My Awesome Experiment</title>

    <!-- Psych.js Imports -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" integrity="sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2" crossorigin="anonymous">
    <script src='https://psychjs.alecneuro.com/index.min.js'></script>
    <!-- Psych.js Imports End -->

</head>
<body id='root'>

    <script>

        // Create settings
        function Settings() {

            return {
                id: {
                    trialnum: 0,
                    blocknum: 1,
                    cong: 2,
                    target: 3,
                    rsi: 4,
                    oddball: 5,
                    novelty: 6,
                    rt: 7,
                    response: 8,
                    acc: 9,
                    feedback_rt: 10,
                    deadline: 11,
                    cols: function() {
                        // Function gets the number of columns in the id field
                        return Object.keys(this).length - 1
                    }
                },
                durations: {
                    rsi: {
                        short: 350,
                        medium: 1700,
                        long: 3000
                    },
                    deadline: 500,
                    deadlineAdj: 25,
                    space: 50,
                    feedback_standard: 200,
                    feedback_oddball: 2000,
                    feedback_oddball_comment: 500,
                    feedback_oddball_comment_buffer: 500,
                    novelty: 200,
                    novelty_buffer: 500,
                    missFeedback: 500,
                    missFeedbackBuffer: 1000
                },
                acc: {
                    miss: 999,
                    postTrialCorrect: 998,
                    postTrialIncorrect: 997,
                    correct: 1,
                    error: 2
                },
                keys: {
                    left: 81,
                    right: 80
                },
                general: {
                    blocks: 2,
                    trials: 36,
                    congruent: 0.5,
                    target: 0.5,
                    rsi: 1 / 3,
                    maxLength: 72 * 3
                },
                colors: {
                    bgColor: '#ccc'
                },
                targets: {
                    left: '<',
                    right: '>'
                },
                responseCodes: {
                    q: 81,
                    p: 80,
                    spacebar: 32
                }
            }

        }

        function insertTrialNums(trialseq, settings) {
            for(let i = 0; i < trialseq.shape()[0]; i++) trialseq.set(i, settings.id.trialnum, i)
            return trialseq
        }

        function has3inaRow(matrix, settings) {

            let [rows] = matrix.shape();

            for(let i = 0; i < rows; i++) {

                // Don't check the first or last rows
                if(i !== 0 && i < rows - 1) {

                    let cong_values = [
                        matrix.get(i, settings.id.cong),
                        matrix.get(i - 1, settings.id.cong),
                        matrix.get(i + 1, settings.id.cong)
                    ]

                    let target_values = [
                        matrix.get(i, settings.id.target),
                        matrix.get(i - 1, settings.id.target),
                        matrix.get(i + 1, settings.id.target)
                    ]

                    let rsi_values = [
                        matrix.get(i, settings.id.rsi),
                        matrix.get(i - 1, settings.id.rsi),
                        matrix.get(i + 1, settings.id.rsi)
                    ]

                    // Get all the novelties surrounding the current trial,
                    // if the sum of all 3 is greater than 1 then we have 2 novelties
                    // next to each other
                    let novelties = [
                        matrix.get(i, settings.id.novelty),
                        matrix.get(i - 1, settings.id.novelty),
                        matrix.get(i +1, settings.id.novelty)
                    ].reduce((a, b) => a + b, 0)
                    
                    if(
                        (cong_values.every((val, i, arr) => val === arr[0]) &&
                        target_values.every((val, i, arr) => val === arr[0]) &&
                        rsi_values.every((val, i, arr) => val === arr[0])) ||
                        novelties > 1
                    ) {
                        return true 
                    }

                }

            }

            return false

        }

        function oddballTooClose(matrix, settings) {

            const oddballs = matrix.getRowsAndColumnsByCriteria(row => row[settings.id.oddball] === 1);
            const distance = Math.abs(oddballs.get(0, settings.id.trialnum) - oddballs.get(1, settings.id.trialnum));
            if(distance < 20) {
                return true
            } else {
                return false
            }

        }

        function oddballOrNoveltyInFirst3(matrix, settings) {

            const s = Matrix.sum([
                matrix.get(0, settings.id.oddball),
                matrix.get(1, settings.id.oddball),
                matrix.get(2, settings.id.oddball),
                matrix.get(0, settings.id.novelty),
                matrix.get(1, settings.id.novelty),
                matrix.get(2, settings.id.novelty),
            ])

            return s > 0 ? true : false;

        }

        function isNotValidBlock(trialseq, settings) {

            // 1. Cannot have 3 of the same trial type in a row
            // 2. Cannot have oddballs within 20 trials of one another
            // 3. Cannot have oddball or novelty in the first 3 trials
            if(
                has3inaRow(trialseq, settings) ||
                oddballTooClose(trialseq, settings) ||
                oddballOrNoveltyInFirst3(trialseq, settings))
            {
                return true
            } else {
                return false
            }

        }

        function isValidNovelty(trialseq, trialnum, i, settings) {

            // Current trial
            const cong = trialseq.get(trialnum, settings.id.cong);
            const nextTrialCong = trialseq.get(trialnum + 1, settings.id.cong);
            const target = trialseq.get(trialnum, settings.id.target);
            const rsi = trialseq.get(trialnum, settings.id.rsi);

            // Search trial
            const searchCong = trialseq.get(i, settings.id.cong);
            const nextSearchCong = trialseq.get(i + 1, settings.id.cong);
            const searchTarget = trialseq.get(i, settings.id.target);
            const searchRsi = trialseq.get(i, settings.id.rsi);

            const oddballSum = Matrix.sum([
                i > 1 ? trialseq.get(i - 1, settings.id.oddball) : 0,
                i > 2 ? trialseq.get(i - 2, settings.id.oddball) : 0,
                trialseq.get(i, settings.id.oddball),
                i + 1 < trialseq.shape()[0] ? trialseq.get(i + 1, settings.id.oddball) : 0,
                i + 2 < trialseq.shape()[0] ? trialseq.get(i + 2, settings.id.oddball) : 0
            ]);

            const noveltySum = Matrix.sum([
                i > 1 ? trialseq.get(i - 1, settings.id.novelty) : 0,
                i > 2 ? trialseq.get(i - 2, settings.id.novelty) : 0,
                trialseq.get(i, settings.id.novelty),
                i + 1 < trialseq.shape()[0] ? trialseq.get(i + 1, settings.id.novelty) : 0,
                i + 2 < trialseq.shape()[0] ? trialseq.get(i + 2, settings.id.novelty) : 0
            ]);

            if(
                oddballSum === 0 &&
                noveltySum === 0 &&
                cong === searchCong &&
                nextTrialCong === nextSearchCong &&
                target === searchTarget &&
                rsi === searchRsi
            ) {
                return true
            } else {
                return false
            }

        }

        function appendNovelty(trialseq, trialnum, settings) {

            const cong = trialseq.get(trialnum, settings.id.cong);
            const nextTrialCong = trialseq.get(trialnum + 1, settings.id.cong);
            const rsi = trialseq.get(trialnum, settings.id.rsi);
            const target = trialseq.get(trialnum, settings.id.target);

            const matrix = createAppendableTrialseq(settings, cong, nextTrialCong, rsi, target);

            trialseq = Matrix.append([ trialseq, matrix ]);

            return trialseq

        }

        function createAppendableTrialseq(settings, targetCongruency, targetNextTrialCongruency, targetRsi, targetDirection) {
                const total_rows = 12;
                var block = new Matrix(total_rows, settings.id.cols());

                const cong_total = total_rows / 2;
                const target_total = total_rows / 2;
                const rsi_total = total_rows / 3;

                const congruent = shuffle3InaRow([
                    ...Matrix.full(cong_total, 1),
                    ...Matrix.full(cong_total, 2)
                ])

                const target = shuffle3InaRow([
                    ...Matrix.full(target_total, 1),
                    ...Matrix.full(target_total, 2)
                ])

                const rsi = shuffle3InaRow([
                    ...Matrix.full(rsi_total, settings.durations.rsi.short),
                    ...Matrix.full(rsi_total, settings.durations.rsi.medium),
                    ...Matrix.full(rsi_total, settings.durations.rsi.long)
                ])

                block.setColFromArray(settings.id.cong, congruent);
                block.setColFromArray(settings.id.target, target);
                block.setColFromArray(settings.id.rsi, rsi);
                
                // Select a random location in the middle of the sequence
                const idx = Matrix.randInt(2, 8);
                
                // Just modify things to fit params
                block.set(idx, settings.id.cong, targetCongruency);
                block.set(idx + 1, settings.id.cong, targetNextTrialCongruency);
                block.set(idx, settings.id.rsi, targetRsi);
                block.set(idx, settings.id.target, targetDirection);

                return block
        }

        function moveOddball(trialseq, trialnum, settings) {

            // Unset the current oddball
            trialseq.set(trialnum, settings.id.oddball, 0);

            if(trialnum + 2 < trialseq.shape()[0]) {
                
                for(let i = trialnum + 2; i < trialseq.shape()[0] - 1; i++) {

                    // If we're outside the current block, then we can just break
                    if(trialseq.get(trialnum, settings.id.block) !== trialseq.get(i, settings.id.block)) {
                        console.log(`No more oddball spots available in current block, nothing set`);
                        break;
                    }

                    // Check for oddballs/novelties on current trial, before, and after
                    const s = Matrix.sum([
                        trialseq.get(i - 1, settings.id.oddball),
                        trialseq.get(i - 1, settings.id.novelty),
                        trialseq.get(i, settings.id.oddball),
                        trialseq.get(i, settings.id.novelty),
                        i + 1 < trialseq.shape()[0] ? trialseq.get(i + 1, settings.id.oddball) : 0,
                        i + 1 < trialseq.shape()[0] ? trialseq.get(i + 1, settings.id.novelty) : 0
                    ])

                    if(s === 0) {
                        trialseq.set(i, settings.id.oddball, 1);
                        break;
                    }

                }

            }

            return trialseq

        }

        function insertNovelty(trialseq, trialnum, settings) {

            if(trialnum + 3 < trialseq.shape()[0]) {

                for(let i = trialnum + 3; i < trialseq.shape()[0] - 1; i++) {

                    if(isValidNovelty(trialseq, trialnum, i, settings)) {
                        trialseq.set(i, settings.id.novelty, 1);

                        if(trialseq.get(i, settings.id.oddball) === 1) {
                            trialseq = moveOddball(trialseq, i, settings)
                        }
                        return trialseq
                    }
    
                }

                // If we didn't find a place to insert it then we need to append
                // new trials to the sequence, but only if we haven't exceeded our maximum number of trials
                if(trialseq.shape()[0] < settings.general.trials * (settings.general.blocks + 1)) {
                    const nextTrialCongruency = trialseq.get(trialnum, settings.id.cong);
                    trialseq = appendNovelty(trialseq, trialnum, settings, nextTrialCongruency);
                }

            }

            return trialseq

        }

        function shuffle3InaRow(arr) {

            var isDone = false;
            arr = Matrix.shuffleArray(arr);
            while (Matrix.scan(arr, 3)) arr = Matrix.shuffleArray(arr)
            return arr;

        }

        function getOddballIndicies(settings) {

            var val1 = Matrix.randInt(0, settings.general.trials);
            var val2 = Matrix.randInt(0, settings.general.trials);
            while(
                val1 - val2 < 20 ||
                val1 === 0 ||
                val1 === 1 ||
                val1 === 2 ||
                val2 === 0 ||
                val2 === 1 ||
                val2 === 2
            ) {
                val1 = Matrix.randInt(0, settings.general.trials);
                val2 = Matrix.randInt(0, settings.general.trials);
            }
            return [val1, val2];

        }

        function getOddballsForBlock(trialseq, settings) {

            // First get the indicies of where we would place the oddballs
            // (at least 20 trials apart)
            var [oddball_idx1, oddball_idx2] = getOddballIndicies(settings);

            // Now make sure that those are on congruent trials
            while(
                trialseq.get(oddball_idx1, settings.id.cong) !== 1 ||
                trialseq.get(oddball_idx2, settings.id.cong) !== 1
            ) [oddball_idx1, oddball_idx2] = getOddballIndicies(settings)

            const oddballs = Matrix.zeros(settings.general.trials);
            oddballs[oddball_idx1] = 1;
            oddballs[oddball_idx2] = 1;
            return oddballs;

        }

        function Trialseq(settings) {

            var trialseq = undefined;

            for(let ib = 0; ib < settings.general.blocks; ib++) {

                const block = new Matrix(settings.general.trials, settings.id.cols());

                const cong_total = settings.general.trials * settings.general.congruent;
                const target_total = settings.general.trials * settings.general.target;
                const rsi_total = settings.general.trials * settings.general.rsi;

                const congruent = shuffle3InaRow([
                    ...Matrix.full(cong_total, 1),
                    ...Matrix.full(cong_total, 2)
                ])

                const target = shuffle3InaRow([
                    ...Matrix.full(target_total, 1),
                    ...Matrix.full(target_total, 2)
                ])

                const rsi = shuffle3InaRow([
                    ...Matrix.full(rsi_total, settings.durations.rsi.short),
                    ...Matrix.full(rsi_total, settings.durations.rsi.medium),
                    ...Matrix.full(rsi_total, settings.durations.rsi.long)
                ])

                block.setColFromArray(settings.id.cong, congruent);
                block.setColFromArray(settings.id.target, target);
                block.setColFromArray(settings.id.rsi, rsi);

                // Set the oddball locations
                const oddballs = getOddballsForBlock(block, settings);
                block.setColFromArray(settings.id.oddball, oddballs);

                // Set block number
                const blocknums = Matrix.full(settings.general.trials, ib);
                block.setColFromArray(settings.id.blocknum, blocknums);

                // Append to trialseq
                trialseq = trialseq ? Matrix.append([ trialseq, block ]) : block

            }

            // Insert trial nums
            trialseq = insertTrialNums(trialseq, settings);

            // Insert deadlines
            trialseq.setColFromArray(settings.id.deadline, Matrix.full(trialseq.shape()[0], 500));

            return trialseq

        }

        async function main() {

            // These functions need to be written here for scoping issues
            var postTrialCheck = (e, trialseq, i, settings, rt, shouldPostCheck) => {

                if(
                    shouldPostCheck &&
                    trialseq.get(i, settings.id.response) === 0 &&
                    (
                        e.keyCode === settings.keys.left ||
                        e.keyCode === settings.keys.right
                    )
                ) {

                    // Get current trial expected key code
                    const currentTrialCode = trialseq.get(i, settings.id.target) === 1 ? settings.keys.left : settings.keys.right;

                    // Record the response direction
                    if(e.keyCode === settings.keys.left) {
                        trialseq.set(i, settings.id.response, 1);
                    } else if (e.keyCode === settings.keys.right) {
                        trialseq.set(i, settings.id.response, 2);
                    }

                    // Set rt
                    trialseq.set(i, settings.id.rt, rt);

                    // If keycodes match, correct trial
                    if(e.keyCode === currentTrialCode) {
                        trialseq.set(i, settings.id.acc, settings.acc.postTrialCorrect);
                    } else {
                        // Otherwise they made an error
                        trialseq.set(i, settings.id.acc, settings.acc.postTrialIncorrect);
                    }

                }

            }
            var postTrialCheckWrap = (e) => postTrialCheck(e, trialseq, i, settings, performance.now() - targetStart.timestamp, shouldPostCheck)

            const settings = Settings();
            var trialseq = Trialseq(settings);

            Psych.init({ backgroundColor: settings.colors.bgColor });

            trialseq.print();

            const dims = Psych.dims();

            // Flankers + target stimuli
            const target = Psych.divWithText({
                text: '',
                letterSpacing: '3px',
                color: 'black',
                fontSize: '8em'
            }, {
                top: `${dims.height / 2}px`,
                left: `${dims.width / 2}px`,
                borderRadius: '5px',
                width: '100%',
                height: '100px',
                backgroundColor: settings.colors.bgColor
            })

            // Standard event
            const triangle = Psych.makeShape('triangle', {
                top: dims.height / 2,
                left: dims.width / 2,
                strokeStyle: 'black',
                fillStyle: settings.colors.bgColor,
                lineWidth: 20,
                size: 300
            })

            // Oddball
            const oddball = Psych.makeShape('triangle', {
                rotate: 180,
                top: dims.height / 2,
                left: dims.width / 2,
                strokeStyle: 'black',
                fillStyle: settings.colors.bgColor,
                lineWidth: 20,
                size: 300
            })

            // Correct feedback
            const correctFeedback = Psych.divWithText({
                text: 'Correct!',
                color: 'blue',
                fontWeight: 'bold',
                letterSpacing: '1px',
                fontSize: '7em'
            }, {
                top: `${dims.height / 2}px`,
                left: `${dims.width / 2}px`,
                width: '100%',
                height: '100px',
                backgroundColor: settings.colors.bgColor
            })

            // Incorrect feedback
            const incorrectFeedback = Psych.divWithText({
                text: 'You took too long to respond!',
                color: '#FF0000',
                letterSpacing: '1px',
                fontSize: '3em'
            }, {
                top: `${dims.height / 2}px`,
                left: `${dims.width / 2}px`,
                width: '100%',
                height: '100px',
                backgroundColor: settings.colors.bgColor
            })

            // Novelty
            const novelty = Psych.divWithText({
                text: 'NOVELTY!',
                color: '#FF0000',
                letterSpacing: '1px',
                fontSize: '3em'
            }, {
                top: `${dims.height / 2}px`,
                left: `${dims.width / 2}px`,
                width: '100%',
                height: '100px',
                backgroundColor: settings.colors.bgColor
            })

            // Miss feedback
            const missFeedback = Psych.divWithText({
                text: 'MISS!',
                color: 'red',
                fontWeight: 'bold',
                letterSpacing: '1px',
                fontSize: '7em'
            }, {
                top: `${dims.height / 2}px`,
                left: `${dims.width / 2}px`,
                width: '100%',
                height: '150px',
                backgroundColor: settings.colors.bgColor
            })

            const screenItems = [ target, triangle, oddball, correctFeedback, incorrectFeedback, novelty, missFeedback ];

            Psych.prepare(screenItems);

            await Psych.welcome();

            var shouldPostCheck = false; // flag for checking post-target responses
            let [trials] = trialseq.shape();
            console.log(trials);
            var i = 0;
            while(i < trialseq.shape()[0]) {

                console.log(`Trial number: ${i}`);

                // COUNTDOWN
                if(i === 0 || trialseq.get(i - 1, settings.id.blocknum) !== trialseq.get(i, settings.id.blocknum)) {
                    await Psych.countdown();
                }

                // First get the direction of the target
                const target_direction = trialseq.get(i, settings.id.target) === 1 ? settings.targets.left : settings.targets.right;

                // Get the flanker directions
                var flanker
                if(trialseq.get(i, settings.id.cong) === 1 && target_direction === settings.targets.left) {
                    flanker = settings.targets.left
                } else if (trialseq.get(i, settings.id.cong) === 1 && target_direction === settings.targets.right) {
                    flanker = settings.targets.right
                } else if (trialseq.get(i, settings.id.cong) === 2 && target_direction === settings.targets.left) {
                    flanker = settings.targets.right
                } else if (trialseq.get(i, settings.id.cong) === 2 && target_direction === settings.targets.right) {
                    flanker = settings.targets.left
                }

                // Build the full target + flankers & attach to target
                target.firstChild.innerText = flanker + flanker + target_direction + flanker + flanker;

                // TARGET START
                var targetStart = Psych.display([ target ]);

                // Wait 500ms for a response
                const response = await targetStart.waitForKeysWithTimeout(Object.values(settings.keys), settings.durations.deadline);

                // There was either a response, or the timeout expired.
                // As long as this is not an oddball/novel trial, the RSI begins now
                const targetEnd = Psych.hide([ target ]);

                // Post trial checker that checks until the end of the trial
                shouldPostCheck = true;
                postTrialCheckWrap.bind(this, trialseq, i, settings, targetStart, shouldPostCheck); // fix scoping
                document.addEventListener('keydown', postTrialCheckWrap);

                // CODE ACCURACY
                if(response.keyPressed) {

                    // Get current trial expected key code
                    const currentTrialCode = trialseq.get(i, settings.id.target) === 1 ? settings.keys.left : settings.keys.right;

                    // First record response direction
                    if(response.keyCode === settings.keys.left) {
                        trialseq.set(i, settings.id.response, 1);
                    } else {
                        trialseq.set(i, settings.id.response, 2);
                    }

                    // If keycodes match, correct trial
                    if(response.keyCode === currentTrialCode) {
                        trialseq.set(i, settings.id.acc, settings.acc.correct); // accuracy
                        trialseq.set(i, settings.id.rt, response.elapsed); // rt
                    } else {
                        // Otherwise they made an error
                        trialseq.set(i, settings.id.acc, settings.acc.error); // accuracy
                        trialseq.set(i, settings.id.rt, response.elapsed); // rt

                        // If they made an error, then we need to insert the next valid novelty event
                        trialseq = insertNovelty(trialseq, i, settings);
                    }

                } else {

                    // Nothing pressed, miss
                    trialseq.set(i, settings.id.acc, settings.acc.miss);

                    // If the current trial is an oddball then move it
                    if(trialseq.get(i, settings.id.oddball) === 1) {
                        trialseq = moveOddball(trialseq, i, settings);
                    }

                    // If the current trial is a novelty and we got a miss, then
                    // unset it and find another comparable trial
                    if(trialseq.get(i, settings.id.novelty) === 1) {
                        trialseq.set(i, settings.id.novelty, 0); // first unset current trial
                        trialseq = insertNovelty(trialseq, i, settings);
                    }

                }

                // FEEDBACK
                if(trialseq.get(i, settings.id.oddball) === 1) {

                    // ODDBALL

                    // Oddball event
                    const oddballStart = Psych.display([ oddball ]);

                    // Wait for oddball response
                    const oddballResponse = await oddballStart.waitForKeyWithTimeout(settings.responseCodes.spacebar, settings.durations.feedback_oddball);

                    // Hide the oddball
                    Psych.hide([ oddball ]);

                    // Get the feedback type and record rt
                    const fb = oddballResponse.keyPressed ? correctFeedback : incorrectFeedback;
                    const feedback_rt = oddballResponse.keyPressed ? oddballResponse.elapsed : 0;
                    trialseq.set(i, settings.id.feedback_rt, feedback_rt);

                    // Display feedback
                    const fbStart = Psych.display([ fb ]);

                    // For feedback duration
                    const fbEnd = await fbStart.waitUntil(settings.durations.feedback_oddball_comment);

                    // Hide feedback
                    Psych.hide([ fb ]);

                    // Wait buffer duration
                    await fbEnd.psychTime.waitUntil(settings.durations.feedback_oddball_comment_buffer);

                } else if (trialseq.get(i, settings.id.novelty) === 1) {

                    // NOVELTY

                    // Novelty event
                    const noveltyStart = Psych.display([ novelty ]);

                    // Wait duration of the novelty
                    await noveltyStart.waitUntil(settings.durations.novelty);

                    // Hide novelty
                    Psych.hide([ novelty ]);

                    // Wait out the rest of the RSI
                    await targetEnd.waitUntil(trialseq.get(i, settings.id.rsi));

                } else if (trialseq.get(i, settings.id.acc) === 999) {

                    // MISS

                    // If its a "miss" then display FASTER! feedback
                    const feedbackStart = Psych.display([ missFeedback ]);

                    // Wait 500ms
                    const feedbackEnd = await feedbackStart.waitUntil(settings.durations.missFeedback);

                    // Hide feedback
                    Psych.hide([ missFeedback ]);

                    // Give a 1000ms buffer to the next trial
                    await feedbackEnd.psychTime.waitUntil(settings.durations.missFeedbackBuffer);
                
                } else {

                    // STANDARD

                    // Standard event
                    const feedbackStart = Psych.display([ triangle ]);

                    // Wait the duration of the feedback
                    await feedbackStart.waitUntil(settings.durations.feedback_standard);

                    // Hide the feedback
                    Psych.hide([ triangle ]);

                    // Wait out the rest of the RSI
                    await targetEnd.waitUntil(trialseq.get(i, settings.id.rsi));

                }

                shouldPostCheck = false;

                // Block feedback
                if(i + 1 === trialseq.shape()[0] || trialseq.get(i, settings.id.blocknum) !== trialseq.get(i + 1, settings.id.blocknum)) {

                    // Extract current block
                    const block = trialseq.getRowsAndColumnsByCriteria(row => row[settings.id.blocknum] === trialseq.get(i, settings.id.blocknum));

                    // Separate by accuracy
                    const corr = block.getRowsAndColumnsByCriteria(row => row[settings.id.acc] === 1);
                    const err = block.getRowsAndColumnsByCriteria(row => row[settings.id.acc] === 2);
                    const miss = block.getRowsAndColumnsByCriteria(row => row[settings.id.acc] === 999);

                    // Calculate rt
                    const rt = corr ? Matrix.mean(corr.getCol(settings.id.rt)) : 0;

                    // Calculate ratios
                    const err_pct = err ? parseInt((err.shape()[0] / block.shape()[0]) * 100) : 0;
                    const miss_pct = miss ? parseInt((miss.shape()[0] / block.shape()[0]) * 100) : 0;

                    // Create block feedback
                    const fb = [
                        `Mean reaction time: ${rt}`,
                        `Errors: ${err_pct}%`,
                        `Misses: ${miss_pct}%`
                    ];

                    // If we aren't at the end of the experiment
                    if(i + 1 !== trialseq.shape()[0]) {

                        // Adjust the deadline for the block if we have to
                        if(err_pct <= 10 && miss_pct <= 10) {
                            const currentDeadline = trialseq.get(i, settings.id.deadline);
                            const newDeadline = currentDeadline - settings.durations.deadlineAdj;
                            for(let ii = i + 1; ii < trialseq.shape()[0]; ii++) trialseq.set(ii, settings.id.deadline, newDeadline);
                        } else if (err_pct >= 25 || miss_pct > 10) {
                            const currentDeadline = trialseq.get(i, settings.id.deadline);
                            const newDeadline = currentDeadline - settings.durations.deadlineAdj;
                            for(let ii = i + 1; ii < trialseq.shape()[0]; ii++) trialseq.set(ii, settings.id.deadline, newDeadline);
                        }

                    }

                    await Psych.blockFeedback(fb);

                }

                trialseq.print();

                // Proceed to next trial
                i++;

            }

            await Psych.welcome({ text: 'Task complete! Thank you for participating :)' });

        }

        
        (async () => {
            
            await main();
            
        })();

    </script>

</body>
</html>