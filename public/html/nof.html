<!DOCTYPE html>
<html lang="en">
<head>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Experiment Title -->
    <title>My Awesome Experiment</title>

    <!-- Psych.js Imports -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" integrity="sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2" crossorigin="anonymous">
    <script src='https://psychjs.alecneuro.com/index.min.js'></script>
    <!-- Psych.js Imports End -->

    <!-- CSS -->
    <style>
        .index-wrap {
            width: 80%;
            margin: 50px auto 300px auto;
        }
        .index-wrap-title {
            text-align: center;
            margin-bottom: 25px;
        }
        .index-wrap-paragraph { font-size: 28px; }
        .list-item { font-size: 22px; }
        .bold { font-weight: bold; }
        .text-blue { color: blue; }
        .text-purple { color: purple; }
        .text-red { color: red; }
        .btn { margin: 25px 0px; }
    </style>

</head>
<body id='root'>

    <div class="index-wrap">
        <h1 class='index-wrap-title'>Welcome to the Wessel Lab HIT</h1>
        <h1 class='index-wrap-title'>Read these instructions <span class='text-red'>very carefully!</span></h1>
        <p class='index-wrap-paragraph'>
            This HIT will present five arrows (e.g. <<<<< or >><>>) in the middle of your
            screen. You are asked to respond to only the middle arrow on each trial
            by pressing the assigned key. It should take approximately 50-60 minutes
            to complete this task. (Your participation time is going to be logged).
        </p>
        <p class='index-wrap-paragraph'>
            <span class='bold'>
                There are several things you must do for a successful participation.
            </span>
            <ol>
                <li class='list-item text-red'>
                    Close all tabs except the Amazon Mechanical Turk code submission
                    tab and the current study tab in your internet browser.
                </li>
                <li class='list-item text-red'>
                    Maximize your browser to full screen, and do not change this until
                    you have fully completed the experiment.
                </li>
                <li class='list-item'>
                    Please try your best and devote all of your attention to the task. We
                    are applying <span class='text-purple'>*rejection/bonus criteria*</span>
                    to encourage workers to give their full attention during participation.
                </li>
                <li class='list-item'>
                    You will be given <span class='text-blue'>a confirmation code</span>
                    after you finish the experiment. Please copy and submit the code
                    to Amazon MTurk.
                </li>
            </ol>
        </p>
        <p class='index-wrap-paragraph'>
            <span class='bold'>
                According to previous studies, workers performed pretty well (above)
                70% accuracy.
            </span>
            <span class='text-purple'>
                If you try your best on the task, we guarantee that you will get a
                small bonus from $0.5 up to $6 (for the top 3% of participants) in addition
                to the base pay of $4! Most participants in the past got
                <span class='text-red'>$7.5-$10</span> from this task when they 'fully engaged'
                in the study for about an hour participation.
            </span>
        </p>
        <p class='index-wrap-paragraph'>
            Before you proceed, you are asked to <span class='bold'>read and submit
            the consent document</span> in the link below. It explains your rights
            as a human participant in our research. If you don't sign and submit
            it before you start the study, your participation cannot be confirmed
            by the <span class='bold'>Institutional Review Board (IRB) of the
            University of Iowa.</span> If you do not follow these instructions, you will
            <span class='bold text-red'>NOT BE PAID</span> even if you finish the HIT.
            Please click the consent document button and submit your consent first.
        </p>
        <a class='btn btn-primary' href='https://redcap.icts.uiowa.edu/redcap/surveys/?s=TPEF9MJTPJ' target='_blank' >Consent Document</a>
        <div class="form-check">
            <input class="form-check-input" type="radio" name="exampleRadios" id="consent-confirmed" value="option1">
            <label class="form-check-label" for="exampleRadios1">
                "I have read and signed the consent document"
            </label>
        </div>
        <div class="form-check">
            <input class="form-check-input" type="radio" name="exampleRadios" id="exampleRadios2" value="option2" checked>
            <label class="form-check-label" for="exampleRadios2">
                "I have not yet read and signed the consent document."
            </label>
        </div>
        <button class='btn btn-primary' id='start-btn' style='display: none;'>Start Experiment</button>
    </div>

    <script>
        document.getElementById('consent-confirmed').addEventListener('click', e => {
            const startBtn = document.getElementById('start-btn');
            startBtn.addEventListener('click', main);
            startBtn.style.display = 'block';
        })
    </script>

    <script>

        function uuid(){  
            let S4 = () => Math.floor((1+Math.random())*0x10000).toString(16).substring(1); 
            let guid = `${S4()}${S4()}-${S4()}-${S4()}-${S4()}-${S4()}${S4()}${S4()}`;
            
            return guid.toLowerCase();  
        }

        function Settings(is_training = false, deadline = 500) {

            var trials = 72;
            var blocks = 8;
            if(is_training === true) {
                trials = 36;
                blocks = 1;
            }

            return {
                is_training,
                id: {
                    trialnum: 0,
                    blocknum: 1,
                    cong: 2,
                    target: 3,
                    rsi: 4,
                    oddball: 5,
                    novelty: 6,
                    rt: 7,
                    response: 8,
                    acc: 9,
                    feedback_rt: 10,
                    deadline: 11,
                    cols: function() {
                        // Function gets the number of columns in the id field
                        return Object.keys(this).length - 1
                    }
                },
                durations: {
                    rsi: {
                        short: 350,
                        medium: 1700,
                        long: 3000
                    },
                    deadline,
                    deadlineAdj: 25,
                    space: 50,
                    feedback_standard: 200,
                    feedback_oddball: 2000,
                    feedback_oddball_comment: 500,
                    feedback_oddball_comment_buffer: 500,
                    novelty: 200,
                    novelty_buffer: 500,
                    missFeedback: 500,
                    missFeedbackBuffer: 1000
                },
                acc: {
                    miss: 999,
                    postTrialCorrect: 998,
                    postTrialIncorrect: 997,
                    correct: 1,
                    error: 2
                },
                keys: {
                    left: 81,
                    right: 80
                },
                general: {
                    blocks,
                    trials,
                    congruent: 0.5,
                    target: 0.5,
                    rsi: 1 / 3,
                    maxTrials: function() {
                        return this.trials * (this.blocks + 2)
                    }
                },
                colors: {
                    bgColor: '#ccc'
                },
                targets: {
                    left: '<',
                    right: '>'
                },
                responseCodes: {
                    q: 81,
                    p: 80,
                    spacebar: 32
                },
                images: {
                    base_url: 'https://psychjs.alecneuro.com/svg/',
                    images: Matrix.shuffleArray([
                        'binder.svg',
                        'bird.svg',
                        'booby.svg',
                        'bunny.svg',
                        'cabinet.svg',
                        'car.svg',
                        'chair.svg',
                        'cittern.svg',
                        'cloud.svg',
                        'couch.svg',
                        'dog.svg',
                        'fan.svg',
                        'goat.svg',
                        'hands.svg',
                        'hen.svg',
                        'leaf.svg',
                        'lemon.svg',
                        'microscope.svg',
                        'mug.svg',
                        'pigeon.svg',
                        'shoe.svg',
                        'truck.svg',
                        'umbrella.svg',
                        'vaccume.svg',
                        'violin.svg',
                        'writing.svg'
                    ]),
                    current_img: 0,
                    image_refs: [],
                    disp_curr_img: function() {
                        this.image_refs[this.current_img].style.display = 'flex';
                        return new PsychTime();
                    },
                    hide_curr_img: function() {
                        this.image_refs[this.current_img].style.display = 'none';
                        return new PsychTime();
                    },
                    next: function() {
                        this.current_img += 1;
                        if(this.current_img >= this.images.length) { this.current_img = 0; }
                    },
                    total_images: function() { return this.images.length },
                    image_urls: function() {
                        var images = {};
                        for(let img of this.images) { images[img] = this.base_url + img; }
                        return images;
                    },
                    create_image: function(id, url) {

                        // Wrapper container
                        const div = document.createElement('div');
                        div.style.height = '100vh';
                        div.style.width = '100vw';
                        div.style.position = 'absolute';
                        div.style.justifyContent = 'center';
                        div.style.alignItems = 'center';
                        div.style.display = 'none';

                        // Image container
                        const img = document.createElement('img');
                        img.src = url;
                        img.style.height = '300px';
                        img.style.width = '300px';

                        // Bind
                        div.appendChild(img);

                        return div

                    },
                    create_images: function() {

                        const images_urls = this.image_urls();
                        for(let [key, value] of Object.entries(images_urls)) {
                            let img = this.create_image(key, value);
                            document.body.appendChild(img);
                            this.image_refs.push(img);
                        }

                    }
                }
            }

        }

        function insertTrialNums(trialseq, settings) {
            for(let i = 0; i < trialseq.shape()[0]; i++) trialseq.set(i, settings.id.trialnum, i)
            return trialseq
        }

        function createAppendableTrialseq(settings, targetCongruency, targetNextTrialCongruency, targetRsi, targetDirection) {
                const total_rows = 12;
                var block = new Matrix(total_rows, settings.id.cols());

                const cong_total = total_rows / 2;
                const target_total = total_rows / 2;
                const rsi_total = total_rows / 3;

                const congruent = shuffle3InaRow([
                    ...Matrix.full(cong_total, 1),
                    ...Matrix.full(cong_total, 2)
                ])

                const target = shuffle3InaRow([
                    ...Matrix.full(target_total, 1),
                    ...Matrix.full(target_total, 2)
                ])

                const rsi = shuffle3InaRow([
                    ...Matrix.full(rsi_total, settings.durations.rsi.short),
                    ...Matrix.full(rsi_total, settings.durations.rsi.medium),
                    ...Matrix.full(rsi_total, settings.durations.rsi.long)
                ])

                block.setColFromArray(settings.id.cong, congruent);
                block.setColFromArray(settings.id.target, target);
                block.setColFromArray(settings.id.rsi, rsi);
                
                // Select a random location in the middle of the sequence
                const idx = Matrix.randInt(2, 8);
                
                // Just modify things to fit params
                block.set(idx, settings.id.cong, targetCongruency);
                block.set(idx + 1, settings.id.cong, targetNextTrialCongruency);
                block.set(idx, settings.id.rsi, targetRsi);
                block.set(idx, settings.id.target, targetDirection);

                // Set it as a novelty
                block.set(idx, settings.id.novelty, 1);

                return block
        }

        function shuffle3InaRow(arr) {

            var isDone = false;
            arr = Matrix.shuffleArray(arr);
            while (Matrix.scan(arr, 3)) arr = Matrix.shuffleArray(arr)
            return arr;

        }

        function error(trialseq, i, settings) {

            // We need to cover 3 options
            // 1. If there isn't enough buffer space for us to search, then append a novelty if
            //    we have not yet exceeded the max length of the trialseq
            // 2. If there is enough buffer space, then search the trialseq for a suitable position
            // 3. If there is no suitable position found by the end of the trialseq, then append a novelty
            //    if we have not exceeded the max length of the trialseq.

            // Init
            const [rows] = trialseq.shape();
            const length = rows - 1;

            // First collect the current trial requirements
            const cong = trialseq.get(i, settings.id.cong);
            const rsi = trialseq.get(i, settings.id.rsi);
            const target = trialseq.get(i, settings.id.target);

            // Now get the next trial congruency, if there is no next trial then just select at random
            const nextCong = i === length ? Matrix.randInt(1, 3) : trialseq.get(i + 1, settings.id.cong);

            // This is the index of the first search trial
            var searchTrial = i + 2;

            // 1) If exceeds buffer space and is less than max length of trialseq, append a novelty
            if(searchTrial >= length && rows < settings.general.maxTrials()) {
                return appendNovelty(trialseq, i, settings, cong, nextCong, rsi, target);
            }

            // 2) Has buffer space, should search
            const nextAvailableNoveltyIndex = findNextNovelty(trialseq, searchTrial, settings, cong, nextCong, rsi, target);
            if(nextAvailableNoveltyIndex !== null) {
                trialseq.set(nextAvailableNoveltyIndex, settings.id.novelty, 1);
                return trialseq;
            }

            // 3) If nothing was inserted, then as long as we're still under our max trial length,
            //    append a novelty
            if(rows < settings.general.maxTrials()) {
                return appendNovelty(trialseq, i, settings, cong, nextCong, rsi, target);
            }

            // If no search was found, and we've exceeded our max trial length, just return the trialseq
            return trialseq

        }

        function appendNovelty(trialseq, trialnum, settings, cong, nextTrialCong, rsi, target) {

            const matrix = createAppendableTrialseq(settings, cong, nextTrialCong, rsi, target);

            // Set the new deadlines
            const deadlines = Matrix.full(matrix.shape()[0], trialseq.get(trialnum - 1, settings.id.deadline));
            matrix.setColFromArray(settings.id.deadline, deadlines);

            // Set the block number
            const blocknums = Matrix.full(matrix.shape()[0], trialseq.get(trialnum - 1, settings.id.blocknum));
            matrix.setColFromArray(settings.id.blocknum, blocknums);

            // Append to the current trialseq
            trialseq = Matrix.append([ trialseq, matrix ]);

            // Reset trial numbers
            trialseq = insertTrialNums(trialseq, settings);

            return trialseq

        }

        function moveOddball(trialseq, searchTrial, settings) {

            // Moves oddball to the next available location relative to the search trial
            // it is unset from.
            // 1. Must be within the same block
            // 2. Must not have any oddballs or novelties before during or after

            // Init
            const searchTrialBlocknum = trialseq.get(searchTrial, settings.id.blocknum);
            var nextOddballIdx = searchTrial + 2;
            const [rows] = trialseq.shape();
            const length = rows - 1;

            // Don't exceed the trialseq length, and stay within the current block
            while(nextOddballIdx <= length && searchTrialBlocknum === trialseq.get(nextOddballIdx, settings.id.blocknum)) {

                // This sums the oddballs and novelties surrounding the current next oddball search index
                const checkSum = Matrix.sum([
                    trialseq.get(nextOddballIdx - 1, settings.id.novelty),
                    trialseq.get(nextOddballIdx, settings.id.novelty),
                    nextOddballIdx + 1 <= rows - 1 ? trialseq.get(nextOddballIdx + 1, settings.id.novelty) : 0,
                    trialseq.get(nextOddballIdx - 1, settings.id.oddball),
                    trialseq.get(nextOddballIdx, settings.id.oddball),
                    nextOddballIdx + 1 <= rows - 1 ? trialseq.get(nextOddballIdx + 1, settings.id.oddball) : 0,
                ]);

                // If everything is clear, then we can set current index as the new oddball location
                if(checkSum === 0) {
                    trialseq.set(nextOddballIdx, settings.id.oddball, 1);
                    return trialseq;
                }

                nextOddballIdx += 1;

            }

            return trialseq;

        }

        function findNextNovelty(trialseq, searchTrial, settings, cong, nextCong, rsi, target) {

            // 1. Search each trial starting on searchTrial
            // 2. If we've reached the second to last trial and there is still no match, exit with 'null'

            const [rows] = trialseq.shape();
            const length = rows - 1;

            for(searchTrial; searchTrial < length; searchTrial++) {

                // In order for these to be a match, they must meet the following criteria
                // 1. Congruency, next trial congruency, rsi, target must all match
                // 2. There must be no novelties before or after the trial
                // 3. If there is an oddball before, during, or after this trial, move it to the next
                //    available oddball location.

                // Collect the search trial variables
                const searchCong = trialseq.get(searchTrial, settings.id.cong);
                const searchNextCong = trialseq.get(searchTrial + 1, settings.id.cong);
                const searchRsi = trialseq.get(searchTrial, settings.id.rsi);
                const searchTarget = trialseq.get(searchTrial, settings.id.target);

                // Check for novelties
                const noveltySum = Matrix.sum([
                    trialseq.get(searchTrial - 1, settings.id.novelty),
                    trialseq.get(searchTrial, settings.id.novelty),
                    trialseq.get(searchTrial + 1, settings.id.novelty),
                ]);

                if(
                    noveltySum === 0 &&
                    cong === searchCong &&
                    nextCong === searchNextCong &&
                    rsi === searchRsi &&
                    target === searchTarget
                ) {

                    // We have found a suitable location.

                    // Now check for oddballs
                    const oddballSum = Matrix.sum([
                        trialseq.get(searchTrial - 1, settings.id.oddball),
                        trialseq.get(searchTrial, settings.id.oddball),
                        trialseq.get(searchTrial + 1, settings.id.oddball)
                    ])
                    if(oddballSum > 0) {

                        // We have found an oddball searby

                        // First set them all to off
                        trialseq.set(searchTrial - 1, settings.id.oddball, 0);
                        trialseq.set(searchTrial, settings.id.oddball, 0);
                        trialseq.set(searchTrial + 1, settings.id.oddball, 0);

                        // Now move it to the next suitable oddball location
                        trialseq = moveOddball(trialseq, searchTrial, settings);

                    }

                    return searchTrial;

                }

            }

            // If nothing gets returned before the loop is done, then we have not found a suitable
            // trial, so we exit with 'null'
            return null;

        }

        function getOddballIndicies(settings) {

            var val1 = Matrix.randInt(0, settings.general.trials);
            var val2 = Matrix.randInt(0, settings.general.trials);
            while(
                val1 - val2 < 15 ||
                val1 === 0 ||
                val1 === 1 ||
                val1 === 2 ||
                val2 === 0 ||
                val2 === 1 ||
                val2 === 2
            ) {
                val1 = Matrix.randInt(0, settings.general.trials);
                val2 = Matrix.randInt(0, settings.general.trials);
            }
            return [val1, val2];

        }

        function getOddballsForBlock(trialseq, settings) {

            // First get the indicies of where we would place the oddballs
            // (at least 20 trials apart)
            var [oddball_idx1, oddball_idx2] = getOddballIndicies(settings);

            // Now make sure that those are on congruent trials
            while(
                trialseq.get(oddball_idx1, settings.id.cong) !== 1 ||
                trialseq.get(oddball_idx2, settings.id.cong) !== 1
            ) [oddball_idx1, oddball_idx2] = getOddballIndicies(settings)

            const oddballs = Matrix.zeros(settings.general.trials);
            oddballs[oddball_idx1] = 1;
            oddballs[oddball_idx2] = 1;
            return oddballs;

        }

        function Trialseq(settings) {

            var trialseq = undefined;

            for(let ib = 0; ib < settings.general.blocks; ib++) {

                const block = new Matrix(settings.general.trials, settings.id.cols());

                const cong_total = settings.general.trials * settings.general.congruent;
                const target_total = settings.general.trials * settings.general.target;
                const rsi_total = settings.general.trials * settings.general.rsi;

                const congruent = shuffle3InaRow([
                    ...Matrix.full(cong_total, 1),
                    ...Matrix.full(cong_total, 2)
                ])

                const target = shuffle3InaRow([
                    ...Matrix.full(target_total, 1),
                    ...Matrix.full(target_total, 2)
                ])

                const rsi = shuffle3InaRow([
                    ...Matrix.full(rsi_total, settings.durations.rsi.short),
                    ...Matrix.full(rsi_total, settings.durations.rsi.medium),
                    ...Matrix.full(rsi_total, settings.durations.rsi.long)
                ])

                block.setColFromArray(settings.id.cong, congruent);
                block.setColFromArray(settings.id.target, target);
                block.setColFromArray(settings.id.rsi, rsi);

                // Set the oddball locations
                const oddballs = getOddballsForBlock(block, settings);
                block.setColFromArray(settings.id.oddball, oddballs);

                // Set block number
                const blocknums = Matrix.full(settings.general.trials, ib);
                block.setColFromArray(settings.id.blocknum, blocknums);

                // Append to trialseq
                trialseq = trialseq ? Matrix.append([ trialseq, block ]) : block;

            }

            // Insert trial nums
            trialseq = insertTrialNums(trialseq, settings);

            // Insert deadlines
            trialseq.setColFromArray(settings.id.deadline, Matrix.full(trialseq.shape()[0], settings.durations.deadline));

            return trialseq

        }

        async function experiment(client, is_training = false, deadline = 500) {

            // These functions need to be written here for scoping issues
            var postTrialCheck = (e, trialseq, i, settings, rt, shouldPostCheck) => {

                if(
                    shouldPostCheck &&
                    trialseq.get(i, settings.id.response) === 0 &&
                    (
                        e.keyCode === settings.keys.left ||
                        e.keyCode === settings.keys.right
                    )
                ) {

                    // Get current trial expected key code
                    const currentTrialCode = trialseq.get(i, settings.id.target) === 1 ? settings.keys.left : settings.keys.right;

                    // Record the response direction
                    if(e.keyCode === settings.keys.left) {
                        trialseq.set(i, settings.id.response, 1);
                    } else if (e.keyCode === settings.keys.right) {
                        trialseq.set(i, settings.id.response, 2);
                    }

                    // Set rt
                    trialseq.set(i, settings.id.rt, rt);

                    // If keycodes match, correct trial
                    if(e.keyCode === currentTrialCode) {
                        trialseq.set(i, settings.id.acc, settings.acc.postTrialCorrect);
                    } else {
                        // Otherwise they made an error
                        trialseq.set(i, settings.id.acc, settings.acc.postTrialIncorrect);
                    }

                }

            }
            var postTrialCheckWrap = (e) => postTrialCheck(e, trialseq, i, settings, performance.now() - targetStart.timestamp, shouldPostCheck)

            const settings = Settings(is_training, deadline);
            var trialseq = Trialseq(settings);

            client.trialseq = trialseq;

            Psych.init({ backgroundColor: settings.colors.bgColor });

            trialseq.print();

            const dims = Psych.dims();

            // Flankers + target stimuli
            const target = Psych.divWithText({
                text: '',
                letterSpacing: '3px',
                color: 'black',
                fontSize: '8em'
            }, {
                top: `${dims.height / 2}px`,
                left: `${dims.width / 2}px`,
                borderRadius: '5px',
                width: '100%',
                height: '100px',
                backgroundColor: settings.colors.bgColor
            })

            // Standard event
            const triangle = Psych.makeShape('triangle', {
                top: dims.height / 2,
                left: dims.width / 2,
                strokeStyle: 'black',
                fillStyle: settings.colors.bgColor,
                lineWidth: 20,
                size: 300
            })

            // Oddball
            const oddball = Psych.makeShape('triangle', {
                rotate: 180,
                top: dims.height / 2,
                left: dims.width / 2,
                strokeStyle: 'black',
                fillStyle: settings.colors.bgColor,
                lineWidth: 20,
                size: 300
            })

            // Correct feedback
            const correctFeedback = Psych.divWithText({
                text: 'Correct!',
                color: 'blue',
                fontWeight: 'bold',
                letterSpacing: '1px',
                fontSize: '7em'
            }, {
                top: `${dims.height / 2}px`,
                left: `${dims.width / 2}px`,
                width: '100%',
                height: '100px',
                backgroundColor: settings.colors.bgColor
            })

            // Incorrect feedback
            const incorrectFeedback = Psych.divWithText({
                text: 'You took too long to respond!',
                color: '#FF0000',
                letterSpacing: '1px',
                fontSize: '3em'
            }, {
                top: `${dims.height / 2}px`,
                left: `${dims.width / 2}px`,
                width: '100%',
                height: '100px',
                backgroundColor: settings.colors.bgColor
            })

            // Miss feedback
            const missFeedback = Psych.divWithText({
                text: 'MISS!',
                color: 'red',
                fontWeight: 'bold',
                letterSpacing: '1px',
                fontSize: '7em'
            }, {
                top: `${dims.height / 2}px`,
                left: `${dims.width / 2}px`,
                width: '100%',
                height: '150px',
                backgroundColor: settings.colors.bgColor
            })

            // Gather the screen items loaded with Psych.js
            const screenItems = [ target, triangle, oddball, correctFeedback, incorrectFeedback, missFeedback ];

            // Prepare all images to the screen
            Psych.prepare(screenItems);

            // Load all the novelty images to the screen
            settings.images.create_images();

            await Psych.welcome();

            var shouldPostCheck = false; // flag for checking post-target responses
            let [trials] = trialseq.shape();
            var i = 0;
            var errorCount = 0;
            var noveltyDisplayCount = 0;
            while(i < trialseq.shape()[0]) {

                console.log(`Trial number: ${i}`);

                // COUNTDOWN
                if(i === 0 || trialseq.get(i - 1, settings.id.blocknum) !== trialseq.get(i, settings.id.blocknum)) {
                    await Psych.countdown();
                }

                // First get the direction of the target
                const target_direction = trialseq.get(i, settings.id.target) === 1 ? settings.targets.left : settings.targets.right;

                // Get the flanker directions
                var flanker
                if(trialseq.get(i, settings.id.cong) === 1 && target_direction === settings.targets.left) {
                    flanker = settings.targets.left
                } else if (trialseq.get(i, settings.id.cong) === 1 && target_direction === settings.targets.right) {
                    flanker = settings.targets.right
                } else if (trialseq.get(i, settings.id.cong) === 2 && target_direction === settings.targets.left) {
                    flanker = settings.targets.right
                } else if (trialseq.get(i, settings.id.cong) === 2 && target_direction === settings.targets.right) {
                    flanker = settings.targets.left
                }

                // Build the full target + flankers & attach to target
                target.firstChild.innerText = flanker + flanker + target_direction + flanker + flanker;

                // TARGET START
                var targetStart = Psych.display([ target ]);

                // Wait 500ms for a response
                const response = await targetStart.waitForKeysWithTimeout(Object.values(settings.keys), settings.durations.deadline);

                // There was either a response, or the timeout expired.
                // As long as this is not an oddball/novel trial, the RSI begins now
                const targetEnd = Psych.hide([ target ]);

                // Post trial checker that checks until the end of the trial
                shouldPostCheck = true;
                postTrialCheckWrap.bind(this, trialseq, i, settings, targetStart, shouldPostCheck); // fix scoping
                document.addEventListener('keydown', postTrialCheckWrap);

                // CODE ACCURACY
                if(response.keyPressed) {

                    // Get current trial expected key code
                    const currentTrialCode = trialseq.get(i, settings.id.target) === 1 ? settings.keys.left : settings.keys.right;

                    // First record response direction
                    if(response.keyCode === settings.keys.left) {
                        trialseq.set(i, settings.id.response, 1);
                    } else {
                        trialseq.set(i, settings.id.response, 2);
                    }

                    // If keycodes match, correct trial
                    if(response.keyCode === currentTrialCode) {
                        trialseq.set(i, settings.id.acc, settings.acc.correct); // accuracy
                        trialseq.set(i, settings.id.rt, response.elapsed); // rt
                    } else {
                        // Otherwise they made an error
                        trialseq.set(i, settings.id.acc, settings.acc.error); // accuracy
                        trialseq.set(i, settings.id.rt, response.elapsed); // rt

                        // If we're doing the full experiment, set novelties on errors
                        if(!settings.is_training) {

                            // If they made an error, then we need to insert the next valid novelty event
                            trialseq = error(trialseq, i, settings);
                            errorCount += 1;

                        }
                    }

                } else {

                    // Nothing pressed, miss
                    trialseq.set(i, settings.id.acc, settings.acc.miss);

                    // If the current trial is an oddball then move it
                    if(trialseq.get(i, settings.id.oddball) === 1) {
                        trialseq.set(i, settings.id.oddball, 0); // first unset the current oddball because we can't use it
                        trialseq = moveOddball(trialseq, i, settings);
                    }

                    // If the current trial is a novelty and we got a miss, then
                    // unset it and find another comparable trial
                    if(trialseq.get(i, settings.id.novelty) === 1) {
                        trialseq.set(i, settings.id.novelty, 0); // first unset current trial
                        trialseq = error(trialseq, i, settings); // treat it the same way as you would an error trial
                    }

                }

                // FEEDBACK
                if(trialseq.get(i, settings.id.oddball) === 1) {

                    // ODDBALL

                    // Oddball event
                    const oddballStart = Psych.display([ oddball ]);

                    // Wait for oddball response
                    const oddballResponse = await oddballStart.waitForKeyWithTimeout(settings.responseCodes.spacebar, settings.durations.feedback_oddball);

                    // Hide the oddball
                    Psych.hide([ oddball ]);

                    // Get the feedback type and record rt
                    const fb = oddballResponse.keyPressed ? correctFeedback : incorrectFeedback;
                    const feedback_rt = oddballResponse.keyPressed ? oddballResponse.elapsed : 0;
                    trialseq.set(i, settings.id.feedback_rt, feedback_rt);

                    // Display feedback
                    const fbStart = Psych.display([ fb ]);

                    // For feedback duration
                    const fbEnd = await fbStart.waitUntil(settings.durations.feedback_oddball_comment);

                    // Hide feedback
                    Psych.hide([ fb ]);

                    // Wait buffer duration
                    await fbEnd.psychTime.waitUntil(settings.durations.feedback_oddball_comment_buffer);

                } else if (trialseq.get(i, settings.id.novelty) === 1) {

                    // NOVELTY

                    // Novelty event
                    const noveltyStart = settings.images.disp_curr_img();

                    // Wait duration of the novelty
                    await noveltyStart.waitUntil(settings.durations.novelty);

                    // Hide novelty
                    settings.images.hide_curr_img();
                    settings.images.next();

                    noveltyDisplayCount += 1;

                    // Wait out the rest of the RSI
                    await targetEnd.waitUntil(trialseq.get(i, settings.id.rsi));

                } else if (trialseq.get(i, settings.id.acc) === 999) {

                    // MISS

                    // If its a "miss" then display FASTER! feedback
                    const feedbackStart = Psych.display([ missFeedback ]);

                    // Wait 500ms
                    const feedbackEnd = await feedbackStart.waitUntil(settings.durations.missFeedback);

                    // Hide feedback
                    Psych.hide([ missFeedback ]);

                    // Give a 1000ms buffer to the next trial
                    await feedbackEnd.psychTime.waitUntil(settings.durations.missFeedbackBuffer);
                
                } else {

                    // STANDARD

                    // Standard event
                    const feedbackStart = Psych.display([ triangle ]);

                    // Wait the duration of the feedback
                    await feedbackStart.waitUntil(settings.durations.feedback_standard);

                    // Hide the feedback
                    Psych.hide([ triangle ]);

                    // Wait out the rest of the RSI
                    await targetEnd.waitUntil(trialseq.get(i, settings.id.rsi));

                }

                shouldPostCheck = false;

                // Block feedback
                if(i + 1 === trialseq.shape()[0] || trialseq.get(i, settings.id.blocknum) !== trialseq.get(i + 1, settings.id.blocknum)) {

                    // Save the trial sequence to the server
                    client.save();

                    // Extract current block
                    const block = trialseq.getRowsAndColumnsByCriteria(row => row[settings.id.blocknum] === trialseq.get(i, settings.id.blocknum));

                    // Separate by accuracy
                    const corr = block.getRowsAndColumnsByCriteria(row => row[settings.id.acc] === 1);
                    const err = block.getRowsAndColumnsByCriteria(row => row[settings.id.acc] === 2);
                    const miss = block.getRowsAndColumnsByCriteria(row => row[settings.id.acc] === 999 || row[settings.id.acc] === 998 || row[settings.id.acc] === 997);

                    // Calculate rt
                    const rt = corr ? Matrix.mean(corr.getCol(settings.id.rt)) : 0;

                    // Calculate ratios
                    const err_pct = err ? parseInt((err.shape()[0] / block.shape()[0]) * 100) : 0;
                    const miss_pct = miss ? parseInt((miss.shape()[0] / block.shape()[0]) * 100) : 0;

                    // Create block feedback
                    const fb = [
                        `Mean reaction time: ${rt}`,
                        `Errors: ${err_pct}%`,
                        `Misses: ${miss_pct}%`
                    ];

                    // If we aren't at the end of the experiment
                    if(i + 1 !== trialseq.shape()[0]) {

                        // Adjust the deadline for the block if we have to
                        if(err_pct <= 10 && miss_pct <= 10) {
                            const currentDeadline = trialseq.get(i, settings.id.deadline);
                            const newDeadline = currentDeadline - settings.durations.deadlineAdj;
                            for(let ii = i + 1; ii < trialseq.shape()[0]; ii++) trialseq.set(ii, settings.id.deadline, newDeadline);
                        } else if (err_pct >= 25 || miss_pct > 10) {
                            const currentDeadline = trialseq.get(i, settings.id.deadline);
                            const newDeadline = currentDeadline - settings.durations.deadlineAdj;
                            for(let ii = i + 1; ii < trialseq.shape()[0]; ii++) trialseq.set(ii, settings.id.deadline, newDeadline);
                        }

                    }

                    await Psych.blockFeedback(fb);

                }

                // Proceed to next trial
                i++;

            }

            trialseq.print();
            console.log(`Error count: ${errorCount}`);
            console.log(`Novelty display count: ${noveltyDisplayCount}`);

            await Psych.welcome({ text: 'Task complete! Thank you for participating :)' });

        }
        
        async function main() {

            // Project vars
            const project_name = 'NOF';

            // Clear the DOM
            Psych.clear();

            // Get demographic information
            const demo = await Psych.demographics();

            // Generate their confirmation code / subject number
            demo.id = uuid();

            // Create the api client
            const client = new ApiClient(demo.id, project_name, demo);

            // Run full experiment
            await experiment(client, true);

        }

        (async () => {

            Psych.clear();

            const time = new PsychTime();
            await time.waitForKeysWithTimeout([81, 80], 3000);
            console.log('Done!');

        })();

    </script>

</body>
</html>