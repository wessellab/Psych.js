<!DOCTYPE html>
<html lang="en">
<head>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Experiment Title -->
    <title>My Awesome Experiment</title>

    <!-- Psych.js Imports -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" integrity="sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2" crossorigin="anonymous">
    <script src='https://psychjs.alecneuro.com/index.min.js'></script>
    <!-- Psych.js Imports End -->

    <!-- CSS -->
    <style>
        .index-wrap {
            width: 80%;
            margin: 50px auto 300px auto;
        }
        .index-wrap-title {
            text-align: center;
            margin-bottom: 25px;
        }
        .index-wrap-paragraph { font-size: 28px; }
        .list-item { font-size: 22px; }
        .bold { font-weight: bold; }
        .text-blue { color: blue; }
        .text-purple { color: purple; }
        .text-red { color: red; }
        .btn { margin: 25px 0px; }
    </style>

</head>
<body id='root'>

    <script>

        function uuid(){  
            let S4 = () => Math.floor((1+Math.random())*0x10000).toString(16).substring(1); 
            let guid = `${S4()}${S4()}-${S4()}-${S4()}-${S4()}-${S4()}${S4()}${S4()}`;
            
            return guid.toLowerCase();  
        }

        function Settings(is_training = false, deadline = 850) {

            var trials = 72;
            var blocks = 10;
            if(is_training === true) {
                trials = 36;
                blocks = 1;
            }

            return {
                is_training,
                id: {
                    trialnum: 0,
                    blocknum: 1,
                    cong: 2,
                    target: 3,
                    rsi: 4,
                    oddball: 5,
                    novelty: 6,
                    rt: 7,
                    response: 8,
                    acc: 9,
                    feedback_rt: 10,
                    deadline: 11,
                    cols: function() {
                        // Function gets the number of columns in the id field
                        return Object.keys(this).length - 1
                    }
                },
                durations: {
                    rsi: {
                        short: 350,
                        medium: 1700,
                        long: 3000
                    },
                    minDeadline: 400,
                    maxDeadline: 550,
                    deadline,
                    deadlineAdj: 25,
                    space: 50,
                    feedback_standard: 300,
                    feedback_oddball: 2000,
                    feedback_oddball_comment: 500,
                    feedback_oddball_comment_buffer: 500,
                    novelty: 200,
                    novelty_buffer: 500,
                    missFeedback: 500,
                    missFeedbackBuffer: 1000
                },
                acc: {
                    miss: 999,
                    postTrialCorrect: 998,
                    postTrialIncorrect: 997,
                    correct: 1,
                    error: 2
                },
                keys: {
                    left: 81,
                    right: 80
                },
                general: {
                    blocks,
                    trials,
                    congruent: 0.5,
                    target: 0.5,
                    rsi: 1 / 3,
                    maxTrials: function() {
                        return this.trials * (this.blocks + 2)
                    }
                },
                colors: {
                    bgColor: '#fff'
                },
                targets: {
                    left: '<',
                    right: '>'
                },
                responseCodes: {
                    q: 81,
                    p: 80,
                    spacebar: 32
                },
                images: {
                    base_url: 'https://psychjs.alecneuro.com/gif/',
                    images: Matrix.shuffleArray([
                        '001.gif', '002.gif', '003.gif', '004.gif', '006.gif',
                        '009.gif', '010.gif', '011.gif', '012.gif',
                        '013.gif', '014.gif', '015.gif', '016.gif', '017.gif', '018.gif',
                        '019.gif', '020.gif', '021.gif', '022.gif',
                        '025.gif', '026.gif', '027.gif', '028.gif', '029.gif', '030.gif',
                        '031.gif', '032.gif', '033.gif', '034.gif', '035.gif', '036.gif',
                        '037.gif', '038.gif', '039.gif', '041.gif', '042.gif',
                        '043.gif', '044.gif', '045.gif', '046.gif', '047.gif', '048.gif',
                        '049.gif', '051.gif', '052.gif', '053.gif', '054.gif',
                        '055.gif', '056.gif', '057.gif', '058.gif', '059.gif', '060.gif',
                        '061.gif', '062.gif', '064.gif', '065.gif', '066.gif',
                        '067.gif', '068.gif', '069.gif', '070.gif', '071.gif', '072.gif',
                        '073.gif', '075.gif', '076.gif', '077.gif', '078.gif',
                        '079.gif', '080.gif', '081.gif', '082.gif', '084.gif',
                        '085.gif', '087.gif', '089.gif', '090.gif',
                        '091.gif', '092.gif', '095.gif', '096.gif',
                        '097.gif', '098.gif', '099.gif', '100.gif',
                        '101.gif', '102.gif', '103.gif', '104.gif', '105.gif', '106.gif',
                        '107.gif', '108.gif', '109.gif', '111.gif',
                        '113.gif', '114.gif', '116.gif', '117.gif', '118.gif',
                        '120.gif', '121.gif', '122.gif', '123.gif', '124.gif',
                        '125.gif', '126.gif', '127.gif', '128.gif', '129.gif', '130.gif',
                        '131.gif', '132.gif', '133.gif', '135.gif', '136.gif',
                        '137.gif', '138.gif', '139.gif', '140.gif',
                        '143.gif', '144.gif', '145.gif', '146.gif', '147.gif', '148.gif',
                        '149.gif', '150.gif', '151.gif', '153.gif',
                        '156.gif', '157.gif', '158.gif', '159.gif', '160.gif',
                        '161.gif', '162.gif', '163.gif', '164.gif', '165.gif', '166.gif',
                        '167.gif', '168.gif', '169.gif', '170.gif', '171.gif', '172.gif',
                        '173.gif', '174.gif', '175.gif', '176.gif', '177.gif', '178.gif',
                        '179.gif', '180.gif', '181.gif', '182.gif', '183.gif', '184.gif',
                        '185.gif', '186.gif', '187.gif', '188.gif', '189.gif', '190.gif',
                        '191.gif', '192.gif', '193.gif', '194.gif', '195.gif', '196.gif',
                        '197.gif', '198.gif', '199.gif', '200.gif',
                        '201.gif', '202.gif', '203.gif', '204.gif',
                        '205.gif', '206.gif', '207.gif', '208.gif',
                        '210.gif', '211.gif',
                        '213.gif', '214.gif', '215.gif', '216.gif',
                        '218.gif', '219.gif', '220.gif',
                        '221.gif', '222.gif', '223.gif', '224.gif',
                        '225.gif', '226.gif', '227.gif', '228.gif',
                        '229.gif', '230.gif', '232.gif',
                        '233.gif', '234.gif', '236.gif',
                        '237.gif', '238.gif', '239.gif', '240.gif',
                        '241.gif', '242.gif', '243.gif', '244.gif',
                        '245.gif', '246.gif', '247.gif', '248.gif',
                        '249.gif', '250.gif', '251.gif', '252.gif',
                        '253.gif', '254.gif', '255.gif', '256.gif',
                        '257.gif', '258.gif', '259.gif', '260.gif'
                    ]),
                    current_img: 0,
                    image_refs: [],
                    disp_curr_img: function() {
                        this.image_refs[this.current_img].style.display = 'flex';
                        return new PsychTime();
                    },
                    hide_curr_img: function() {
                        this.image_refs[this.current_img].style.display = 'none';
                        return new PsychTime();
                    },
                    next: function() {
                        this.current_img += 1;
                        if(this.current_img >= this.images.length) { this.current_img = 0; }
                    },
                    total_images: function() { return this.images.length },
                    image_urls: function() {
                        var images = {};
                        for(let img of this.images) { images[img] = this.base_url + img; }
                        return images;
                    },
                    create_image: function(id, url) {

                        // Wrapper container
                        const div = document.createElement('div');
                        div.style.height = '100vh';
                        div.style.width = '100vw';
                        div.style.position = 'absolute';
                        div.style.justifyContent = 'center';
                        div.style.alignItems = 'center';
                        div.style.display = 'none';

                        // Image container
                        const img = document.createElement('img');
                        img.src = url;
                        img.style.height = '300px';
                        img.style.width = '300px';

                        // Bind
                        div.appendChild(img);

                        return div

                    },
                    create_images: function() {

                        const images_urls = this.image_urls();
                        for(let [key, value] of Object.entries(images_urls)) {
                            let img = this.create_image(key, value);
                            document.body.appendChild(img);
                            this.image_refs.push(img);
                        }

                    }
                }
            }

        }

        function insertTrialNums(trialseq, settings) {
            for(let i = 0; i < trialseq.shape()[0]; i++) trialseq.set(i, settings.id.trialnum, i)
            return trialseq
        }

        function createAppendableTrialseq(settings, targetCongruency, targetNextTrialCongruency, targetRsi, targetDirection) {
                const total_rows = 6;
                var block = new Matrix(total_rows, settings.id.cols());

                const cong_total = total_rows / 2;
                const target_total = total_rows / 2;
                const rsi_total = total_rows / 3;

                const congruent = shuffle3InaRow([
                    ...Matrix.full(cong_total, 1),
                    ...Matrix.full(cong_total, 2)
                ])

                const target = shuffle3InaRow([
                    ...Matrix.full(target_total, 1),
                    ...Matrix.full(target_total, 2)
                ])

                const rsi = shuffle3InaRow([
                    ...Matrix.full(rsi_total, settings.durations.rsi.short),
                    ...Matrix.full(rsi_total, settings.durations.rsi.medium),
                    ...Matrix.full(rsi_total, settings.durations.rsi.long)
                ])

                block.setColFromArray(settings.id.cong, congruent);
                block.setColFromArray(settings.id.target, target);
                block.setColFromArray(settings.id.rsi, rsi);
                
                // Select a random location in the middle of the sequence
                const idx = Matrix.randInt(2, 5);
                
                // Just modify things to fit params

                // First check to see if what we're modifying is different
                const selectedTrialCongruency = block.get(idx, settings.id.cong);
                if(selectedTrialCongruency !== targetCongruency) {

                    // Then this means we have to go back and find a trial that is this congruency, and replace it so that this stays counterbalanced
                    for(i = 0; i < total_rows; i++) {
                        if(block.get(i, settings.id.cong) === targetCongruency) {
                            block.set(i, settings.id.cong, selectedTrialCongruency);
                            break;
                        }
                    }

                    // Then set it to be the congruency that we want it to be
                    block.set(idx, settings.id.cong, targetCongruency);

                }

                const selectedTrialNextTrialCongruency = block.get(idx + 1, settings.id.cong);
                if(selectedTrialNextTrialCongruency !== targetNextTrialCongruency) {

                    for(i = 0; i < total_rows; i++) {
                        if(block.get(i, settings.id.cong) === targetNextTrialCongruency) {
                            block.set(i, settings.id.cong, selectedTrialNextTrialCongruency);
                            break;
                        }
                    }

                    // Then set it to be the congruency that we want it to be
                    block.set(idx + 1, settings.id.cong, targetNextTrialCongruency);

                }


                const selectedTrialRsi = block.get(idx, settings.id.rsi);
                if(selectedTrialRsi !== targetRsi) {

                    for(i = 0; i < total_rows; i++) {
                        if(block.get(i, settings.id.rsi) === targetRsi) {
                            block.set(i, settings.id.rsi, selectedTrialRsi);
                            break;
                        }
                    }

                    // Then set it to be the congruency that we want it to be
                    block.set(idx, settings.id.rsi, targetRsi);

                }

                // Set it as a novelty
                block.set(idx, settings.id.novelty, 1);

                return block
        }

        function shuffle3InaRow(arr) {

            var isDone = false;
            arr = Matrix.shuffleArray(arr);
            while (Matrix.scan(arr, 3)) arr = Matrix.shuffleArray(arr)
            return arr;

        }

        function error(trialseq, i, settings) {

            // We need to cover 3 options
            // 1. If there isn't enough buffer space for us to search, then append a novelty if
            //    we have not yet exceeded the max length of the trialseq
            // 2. If there is enough buffer space, then search the trialseq for a suitable position
            // 3. If there is no suitable position found by the end of the trialseq, then append a novelty
            //    if we have not exceeded the max length of the trialseq.

            // Init
            const [rows] = trialseq.shape();
            const length = rows - 1;

            // First collect the current trial requirements
            const cong = trialseq.get(i, settings.id.cong);
            const rsi = trialseq.get(i, settings.id.rsi);
            const target = trialseq.get(i, settings.id.target);

            // Now get the next trial congruency, if there is no next trial then just select at random
            const nextCong = i === length ? Matrix.randInt(1, 3) : trialseq.get(i + 1, settings.id.cong);

            // This is the index of the first search trial
            var searchTrial = i + 2;

            // 1) If exceeds buffer space and is less than max length of trialseq, append a novelty
            if(searchTrial >= length && rows < settings.general.maxTrials()) {
                return appendNovelty(trialseq, i, settings, cong, nextCong, rsi, target);
            }

            // 2) Has buffer space, should search
            const nextAvailableNoveltyIndex = findNextNovelty(trialseq, searchTrial, settings, cong, nextCong, rsi, target);
            if(nextAvailableNoveltyIndex !== null) {
                trialseq.set(nextAvailableNoveltyIndex, settings.id.novelty, 1);
                return trialseq;
            }

            // 3) If nothing was inserted, then as long as we're still under our max trial length,
            //    append a novelty
            if(rows < settings.general.maxTrials()) {
                return appendNovelty(trialseq, i, settings, cong, nextCong, rsi, target);
            }

            // If no search was found, and we've exceeded our max trial length, just return the trialseq
            return trialseq

        }

        function appendNovelty(trialseq, trialnum, settings, cong, nextTrialCong, rsi, target) {

            const matrix = createAppendableTrialseq(settings, cong, nextTrialCong, rsi, target);

            // Set the new deadlines
            const deadlines = Matrix.full(matrix.shape()[0], trialseq.get(trialnum - 1, settings.id.deadline));
            matrix.setColFromArray(settings.id.deadline, deadlines);

            // Get the number of "block 8"s that we've appended so far
            const block10Rows = trialseq.getRowsAndColumnsByCriteria(row => row[settings.id.blocknum] == 10);
            const block10Count = block10Rows ? block10Rows.shape()[0] : 0;
 
            const newBlockNumber = block10Count < settings.general.trials ? 10 : 11;

            // Set the block number
            const blocknums = Matrix.full(matrix.shape()[0], newBlockNumber);
            matrix.setColFromArray(settings.id.blocknum, blocknums);

            // Append to the current trialseq
            trialseq = Matrix.append([ trialseq, matrix ]);

            // Reset trial numbers
            trialseq = insertTrialNums(trialseq, settings);

            return trialseq

        }

        function moveOddball(trialseq, searchTrial, settings) {

            // Moves oddball to the next available location relative to the search trial
            // it is unset from.
            // 1. Must be within the same block
            // 2. Must not have any oddballs or novelties before during or after

            // Init
            const searchTrialBlocknum = trialseq.get(searchTrial, settings.id.blocknum);
            var nextOddballIdx = searchTrial + 2;
            const [rows] = trialseq.shape();
            const length = rows - 1;

            // Don't exceed the trialseq length, and stay within the current block
            while(nextOddballIdx <= length && searchTrialBlocknum === trialseq.get(nextOddballIdx, settings.id.blocknum)) {

                // This sums the oddballs and novelties surrounding the current next oddball search index
                const checkSum = Matrix.sum([
                    trialseq.get(nextOddballIdx - 1, settings.id.novelty),
                    trialseq.get(nextOddballIdx, settings.id.novelty),
                    nextOddballIdx + 1 <= rows - 1 ? trialseq.get(nextOddballIdx + 1, settings.id.novelty) : 0,
                    trialseq.get(nextOddballIdx - 1, settings.id.oddball),
                    trialseq.get(nextOddballIdx, settings.id.oddball),
                    nextOddballIdx + 1 <= rows - 1 ? trialseq.get(nextOddballIdx + 1, settings.id.oddball) : 0,
                ]);

                // If everything is clear, then we can set current index as the new oddball location
                if(checkSum === 0) {
                    trialseq.set(nextOddballIdx, settings.id.oddball, 1);
                    return trialseq;
                }

                nextOddballIdx += 1;

            }

            return trialseq;

        }

        function findNextNovelty(trialseq, searchTrial, settings, cong, nextCong, rsi, target) {

            // 1. Search each trial starting on searchTrial
            // 2. If we've reached the second to last trial and there is still no match, exit with 'null'

            const [rows] = trialseq.shape();
            const length = rows - 1;

            for(searchTrial; searchTrial < length; searchTrial++) {

                // In order for these to be a match, they must meet the following criteria
                // 1. Congruency, next trial congruency, rsi, target must all match
                // 2. There must be no novelties before or after the trial
                // 3. If there is an oddball before, during, or after this trial, move it to the next
                //    available oddball location.

                // Collect the search trial variables
                const searchCong = trialseq.get(searchTrial, settings.id.cong);
                const searchNextCong = trialseq.get(searchTrial + 1, settings.id.cong);
                const searchRsi = trialseq.get(searchTrial, settings.id.rsi);
                const searchTarget = trialseq.get(searchTrial, settings.id.target);

                // Check for novelties
                const noveltySum = Matrix.sum([
                    trialseq.get(searchTrial - 1, settings.id.novelty),
                    trialseq.get(searchTrial, settings.id.novelty),
                    trialseq.get(searchTrial + 1, settings.id.novelty),
                ]);

                if(
                    noveltySum === 0 &&
                    cong === searchCong &&
                    nextCong === searchNextCong &&
                    rsi === searchRsi
                ) {

                    // We have found a suitable location.

                    // Now check for oddballs
                    const oddballSum = Matrix.sum([
                        trialseq.get(searchTrial - 1, settings.id.oddball),
                        trialseq.get(searchTrial, settings.id.oddball),
                        trialseq.get(searchTrial + 1, settings.id.oddball)
                    ])
                    if(oddballSum > 0) {

                        // We have found an oddball searby

                        // First set them all to off
                        trialseq.set(searchTrial - 1, settings.id.oddball, 0);
                        trialseq.set(searchTrial, settings.id.oddball, 0);
                        trialseq.set(searchTrial + 1, settings.id.oddball, 0);

                        // Now move it to the next suitable oddball location
                        trialseq = moveOddball(trialseq, searchTrial, settings);

                    }

                    return searchTrial;

                }

            }

            // If nothing gets returned before the loop is done, then we have not found a suitable
            // trial, so we exit with 'null'
            return null;

        }

        function getOddballIndicies(settings) {

            var val1 = Matrix.randInt(0, settings.general.trials);
            var val2 = Matrix.randInt(0, settings.general.trials);
            while(
                val1 - val2 < 15 ||
                val1 === 0 ||
                val1 === 1 ||
                val1 === 2 ||
                val2 === 0 ||
                val2 === 1 ||
                val2 === 2
            ) {
                val1 = Matrix.randInt(0, settings.general.trials);
                val2 = Matrix.randInt(0, settings.general.trials);
            }
            return [val1, val2];

        }

        function getOddballsForBlock(trialseq, settings) {

            // First get the indicies of where we would place the oddballs
            // (at least 20 trials apart)
            var [oddball_idx1, oddball_idx2] = getOddballIndicies(settings);

            // Now make sure that those are on congruent trials
            while(
                trialseq.get(oddball_idx1, settings.id.cong) !== 1 ||
                trialseq.get(oddball_idx2, settings.id.cong) !== 1
            ) [oddball_idx1, oddball_idx2] = getOddballIndicies(settings)

            const oddballs = Matrix.zeros(settings.general.trials);
            oddballs[oddball_idx1] = 1;
            oddballs[oddball_idx2] = 1;
            return oddballs;

        }

        function createTrialseq(settings) {

            // Clear the screen and init the loader
            Psych.clear();
            drawLoader();

            return new Promise((resolve, reject) => {

                var trialseq = undefined;

                var ib = 0;
                let iv = setInterval(() => {
                    console.log(ib);

                    const block = new Matrix(settings.general.trials, settings.id.cols());

                    const cong_total = settings.general.trials * settings.general.congruent;
                    const target_total = settings.general.trials * settings.general.target;
                    const rsi_total = settings.general.trials * settings.general.rsi;

                    const congruent = shuffle3InaRow([
                        ...Matrix.full(cong_total, 1),
                        ...Matrix.full(cong_total, 2)
                    ])

                    const target = shuffle3InaRow([
                        ...Matrix.full(target_total, 1),
                        ...Matrix.full(target_total, 2)
                    ])

                    const rsi = shuffle3InaRow([
                        ...Matrix.full(rsi_total, settings.durations.rsi.short),
                        ...Matrix.full(rsi_total, settings.durations.rsi.medium),
                        ...Matrix.full(rsi_total, settings.durations.rsi.long)
                    ])

                    block.setColFromArray(settings.id.cong, congruent);
                    block.setColFromArray(settings.id.target, target);
                    block.setColFromArray(settings.id.rsi, rsi);

                    // Set the oddball locations
                    const oddballs = getOddballsForBlock(block, settings);
                    block.setColFromArray(settings.id.oddball, oddballs);

                    // Set block number
                    const blocknums = Matrix.full(settings.general.trials, ib);
                    block.setColFromArray(settings.id.blocknum, blocknums);

                    // Append to trialseq
                    trialseq = trialseq ? Matrix.append([ trialseq, block ]) : block;
                
                    // Increase block counter
                    ib += 1;

                    // Update the loader on screen
                    updateLoader();

                    // Exit condition
                    if(ib === settings.general.blocks) { Psych.clear(); clearInterval(iv); resolve(trialseq); }

                }, 1000);

            })
        }

        async function Trialseq(settings) {

            var trialseq = await createTrialseq(settings);

            // Insert trial nums
            trialseq = insertTrialNums(trialseq, settings);

            // Insert deadlines
            trialseq.setColFromArray(settings.id.deadline, Matrix.full(trialseq.shape()[0], settings.durations.deadline));

            return trialseq

        }

        async function experiment(client, is_training = false, deadline = 550) {

            // These functions need to be written here for scoping issues
            var postTrialCheck = (e, trialseq, i, settings, rt, shouldPostCheck) => {

                if(
                    shouldPostCheck &&
                    trialseq.get(i, settings.id.response) === 0 &&
                    (
                        e.keyCode === settings.keys.left ||
                        e.keyCode === settings.keys.right
                    )
                ) {

                    // Get current trial expected key code
                    const currentTrialCode = trialseq.get(i, settings.id.target) === 1 ? settings.keys.left : settings.keys.right;

                    // Record the response direction
                    if(e.keyCode === settings.keys.left) {
                        trialseq.set(i, settings.id.response, 1);
                    } else if (e.keyCode === settings.keys.right) {
                        trialseq.set(i, settings.id.response, 2);
                    }

                    // Set rt
                    trialseq.set(i, settings.id.rt, rt);

                    // If keycodes match, correct trial
                    if(e.keyCode === currentTrialCode) {
                        trialseq.set(i, settings.id.acc, settings.acc.postTrialCorrect);
                    } else {
                        // Otherwise they made an error
                        trialseq.set(i, settings.id.acc, settings.acc.postTrialIncorrect);
                    }

                }

            }
            var postTrialCheckWrap = (e) => postTrialCheck(e, trialseq, i, settings, performance.now() - targetStart.timestamp, shouldPostCheck)

            const settings = Settings(is_training, deadline);
            var trialseq = await Trialseq(settings);

            client.trialseq = trialseq;

            Psych.init({ backgroundColor: settings.colors.bgColor });

            trialseq.print();

            const dims = Psych.dims();

            // Flankers + target stimuli
            const target = Psych.divWithText({
                text: '',
                letterSpacing: '3px',
                color: 'black',
                fontSize: '8em'
            }, {
                top: `${dims.height / 2}px`,
                left: `${dims.width / 2}px`,
                borderRadius: '5px',
                width: '100%',
                height: '100px',
                backgroundColor: settings.colors.bgColor
            })

            // Standard event
            const triangle = Psych.makeShape('triangle', {
                top: dims.height / 2,
                left: dims.width / 2,
                strokeStyle: 'black',
                fillStyle: settings.colors.bgColor,
                lineWidth: 20,
                size: 300
            })

            // Oddball
            const oddball = Psych.makeShape('triangle', {
                rotate: 180,
                top: dims.height / 2,
                left: dims.width / 2,
                strokeStyle: 'black',
                fillStyle: settings.colors.bgColor,
                lineWidth: 20,
                size: 300
            })

            // Correct feedback
            const correctFeedback = Psych.divWithText({
                text: 'Correct!',
                color: 'blue',
                fontWeight: 'bold',
                letterSpacing: '1px',
                fontSize: '7em'
            }, {
                top: `${dims.height / 2}px`,
                left: `${dims.width / 2}px`,
                width: '100%',
                height: '100px',
                backgroundColor: settings.colors.bgColor
            })

            // Incorrect feedback
            const incorrectFeedback = Psych.divWithText({
                text: 'You took too long to respond!',
                color: '#FF0000',
                letterSpacing: '1px',
                fontSize: '3em'
            }, {
                top: `${dims.height / 2}px`,
                left: `${dims.width / 2}px`,
                width: '100%',
                height: '100px',
                backgroundColor: settings.colors.bgColor
            })

            // Miss feedback
            const missFeedback = Psych.divWithText({
                text: 'FASTER!',
                color: 'red',
                fontWeight: 'bold',
                letterSpacing: '1px',
                fontSize: '7em'
            }, {
                top: `${dims.height / 2}px`,
                left: `${dims.width / 2}px`,
                width: '100%',
                height: '150px',
                backgroundColor: settings.colors.bgColor
            })

            // Gather the screen items loaded with Psych.js
            const screenItems = [ target, triangle, oddball, correctFeedback, incorrectFeedback, missFeedback ];

            // Prepare all images to the screen
            Psych.prepare(screenItems);

            // Load all the novelty images to the screen
            settings.images.create_images();

            // Prescreen
            var text = '';
            if(is_training) {
                text = 'Welcome to the training, you must have <20% errors and <20% misses to move on to the full experiment. Press the space bar to move on...';
            } else {
                text = 'You are about to begin the full experiment.</br></br>This will consist of 12 blocks of trials. Each block will have 72 trials.</br></br>Feel free to take a small break between blocks, but do not reload this page or exit full screen mode.</br></br>Press the spacebar to move on...';
            }
            await Psych.welcome({ text }, 1500)

            await Psych.welcome();

            var shouldPostCheck = false; // flag for checking post-target responses
            let [trials] = trialseq.shape();
            var i = 0;
            while(i < trialseq.shape()[0]) {

                console.log(`Trial number: ${i}`);

                // COUNTDOWN
                if(i === 0 || trialseq.get(i - 1, settings.id.blocknum) !== trialseq.get(i, settings.id.blocknum)) {
                    await Psych.countdown();
                }

                // First get the direction of the target
                const target_direction = trialseq.get(i, settings.id.target) === 1 ? settings.targets.left : settings.targets.right;

                // Get the flanker directions
                var flanker
                if(trialseq.get(i, settings.id.cong) === 1 && target_direction === settings.targets.left) {
                    flanker = settings.targets.left
                } else if (trialseq.get(i, settings.id.cong) === 1 && target_direction === settings.targets.right) {
                    flanker = settings.targets.right
                } else if (trialseq.get(i, settings.id.cong) === 2 && target_direction === settings.targets.left) {
                    flanker = settings.targets.right
                } else if (trialseq.get(i, settings.id.cong) === 2 && target_direction === settings.targets.right) {
                    flanker = settings.targets.left
                }

                // Build the full target + flankers & attach to target
                target.firstChild.innerText = flanker + flanker + target_direction + flanker + flanker;

                // TARGET START
                var targetStart = Psych.display([ target ]);

                // Wait 500ms for a response
                const response = await targetStart.waitForKeysWithTimeout(Object.values(settings.keys), trialseq.get(i, settings.id.deadline));

                // There was either a response, or the timeout expired.
                // As long as this is not an oddball/novel trial, the RSI begins now
                const targetEnd = Psych.hide([ target ]);

                // Post trial checker that checks until the end of the trial
                shouldPostCheck = true;
                postTrialCheckWrap.bind(this, trialseq, i, settings, targetStart, shouldPostCheck); // fix scoping
                document.addEventListener('keydown', postTrialCheckWrap);

                // CODE ACCURACY
                if(response.keyPressed) {

                    // Get current trial expected key code
                    const currentTrialCode = trialseq.get(i, settings.id.target) === 1 ? settings.keys.left : settings.keys.right;

                    // First record response direction
                    if(response.keyCode === settings.keys.left) {
                        trialseq.set(i, settings.id.response, 1);
                    } else {
                        trialseq.set(i, settings.id.response, 2);
                    }

                    // If keycodes match, correct trial
                    if(response.keyCode === currentTrialCode) {
                        trialseq.set(i, settings.id.acc, settings.acc.correct); // accuracy
                        trialseq.set(i, settings.id.rt, response.elapsed); // rt
                    } else {
                        // Otherwise they made an error
                        trialseq.set(i, settings.id.acc, settings.acc.error); // accuracy
                        trialseq.set(i, settings.id.rt, response.elapsed); // rt

                        // If we're doing the full experiment, set novelties on errors
                        if(!settings.is_training) {

                            // If they made an error, then we need to insert the next valid novelty event
                            trialseq = error(trialseq, i, settings);

                            // If the current trial is a novelty and we got an error, then
                            // unset it and find another comparable trial
                            if(trialseq.get(i, settings.id.novelty) === 1) {
                                trialseq.set(i, settings.id.novelty, 0); // first unset current trial
                                trialseq = error(trialseq, i, settings); // treat it the same way as you would an error trial
                            }

                        }
                    }

                } else {

                    // Nothing pressed, miss
                    trialseq.set(i, settings.id.acc, settings.acc.miss);

                    // If the current trial is an oddball then move it
                    if(trialseq.get(i, settings.id.oddball) === 1) {
                        trialseq.set(i, settings.id.oddball, 0); // first unset the current oddball because we can't use it
                        trialseq = moveOddball(trialseq, i, settings);
                    }

                    // If the current trial is a novelty and we got a miss, then
                    // unset it and find another comparable trial
                    if(trialseq.get(i, settings.id.novelty) === 1) {
                        trialseq.set(i, settings.id.novelty, 0); // first unset current trial
                        trialseq = error(trialseq, i, settings); // treat it the same way as you would an error trial
                    }

                }

                // FEEDBACK
                if(trialseq.get(i, settings.id.oddball) === 1) {

                    // ODDBALL

                    // Oddball event
                    const oddballStart = Psych.display([ oddball ]);

                    // Wait for oddball response
                    const oddballResponse = await oddballStart.waitForKeyWithTimeout(settings.responseCodes.spacebar, settings.durations.feedback_oddball);

                    // Hide the oddball
                    Psych.hide([ oddball ]);

                    // Get the feedback type and record rt
                    const fb = oddballResponse.keyPressed ? correctFeedback : incorrectFeedback;
                    const feedback_rt = oddballResponse.keyPressed ? oddballResponse.elapsed : 0;
                    trialseq.set(i, settings.id.feedback_rt, feedback_rt);

                    // Display feedback
                    const fbStart = Psych.display([ fb ]);

                    // For feedback duration
                    const fbEnd = await fbStart.waitUntil(settings.durations.feedback_oddball_comment);

                    // Hide feedback
                    Psych.hide([ fb ]);

                    // Wait buffer duration
                    await fbEnd.psychTime.waitUntil(settings.durations.feedback_oddball_comment_buffer);

                } else if (trialseq.get(i, settings.id.novelty) === 1) {

                    // NOVELTY

                    // Novelty event
                    const noveltyStart = settings.images.disp_curr_img();

                    // Wait duration of the novelty
                    await noveltyStart.waitUntil(settings.durations.novelty);

                    // Hide novelty
                    settings.images.hide_curr_img();
                    settings.images.next();

                    // Wait out the rest of the RSI
                    await targetEnd.waitUntil(trialseq.get(i, settings.id.rsi));

                } else if (trialseq.get(i, settings.id.acc) === 999) {

                    // MISS

                    // If its a "miss" then display FASTER! feedback
                    const feedbackStart = Psych.display([ missFeedback ]);

                    // Wait 500ms
                    const feedbackEnd = await feedbackStart.waitUntil(settings.durations.missFeedback);

                    // Hide feedback
                    Psych.hide([ missFeedback ]);

                    // Give a 1000ms buffer to the next trial
                    await feedbackEnd.psychTime.waitUntil(settings.durations.missFeedbackBuffer);
                
                } else {

                    // STANDARD

                    // Standard event
                    const feedbackStart = Psych.display([ triangle ]);

                    // Wait the duration of the feedback
                    await feedbackStart.waitUntil(settings.durations.feedback_standard);

                    // Hide the feedback
                    Psych.hide([ triangle ]);

                    // Wait out the rest of the RSI
                    await targetEnd.waitUntil(trialseq.get(i, settings.id.rsi));

                }

                shouldPostCheck = false;

                // Adaptive deadline adjustment if full experiment and we've reached 5 trials
                // if(!settings.is_training) {
                //     trialseq = deadlineAdj(trialseq, i, settings);
                // }
                
                // Block feedback
                if(i + 1 === trialseq.shape()[0] || trialseq.get(i, settings.id.blocknum) !== trialseq.get(i + 1, settings.id.blocknum)) {

                    // First we need to update the trialseq reference to the client in case we appended anything
                    client.trialseq = trialseq;

                    // Save the trial sequence to the server
                    client.save();

                    // Extract current block
                    const block = trialseq.getRowsAndColumnsByCriteria(row => row[settings.id.blocknum] === trialseq.get(i, settings.id.blocknum));

                    // Separate by accuracy
                    const corr = block.getRowsAndColumnsByCriteria(row => row[settings.id.acc] === 1);
                    const err = block.getRowsAndColumnsByCriteria(row => row[settings.id.acc] === 2);
                    const miss = block.getRowsAndColumnsByCriteria(row => row[settings.id.acc] === 999 || row[settings.id.acc] === 998 || row[settings.id.acc] === 997);

                    // Calculate rt
                    const rt = corr ? Matrix.mean(corr.getCol(settings.id.rt)) : 0;

                    // Calculate ratios
                    const err_pct = err ? parseInt((err.shape()[0] / block.shape()[0]) * 100) : 0;
                    const miss_pct = miss ? parseInt((miss.shape()[0] / block.shape()[0]) * 100) : 0;

                    // Get the number of oddballs hit correctly
                    const ob = block.getRowsAndColumnsByCriteria(row => row[settings.id.oddball] === 1);
                    const total_obs = ob ? ob.shape()[0] : 0;
                    var obs_hit = 0;
                    if(total_obs > 0) {
                        obs_hit = ob.getRowsAndColumnsByCriteria(row => row[settings.id.feedback_rt] > 0);
                        if(obs_hit !== null) {
                            obs_hit = obs_hit.shape()[0];
                        } else {
                            obs_hit = 0;
                        }
                    }

                    const error_color = err_pct > 20 ? 'red' : 'lightgreen';
                    const miss_color = miss_pct > 10 ? 'red' : 'lightgreen';
                    const oddball_color = obs_hit < total_obs ? 'red' : 'lightgreen';

                    const currentBlockNum = trialseq.get(i, settings.id.blocknum);

                    const total_blocks = settings.is_training ? 1 : settings.general.blocks + 2;

                    // Create block feedback
                    const fb = [
                        `Block: ${currentBlockNum + 1} / ${total_blocks}`,
                        `Mean reaction time: ${rt.toFixed(2)}`,
                        `Errors: <span style='color: ${error_color};'>${err_pct.toFixed(2)}%</span>`,
                        `Misses: <span style='color: ${miss_color};'>${miss_pct.toFixed(2)}%</span>`,
                        `Oddballs hit: <span style='color: ${oddball_color};'>${obs_hit}/${total_obs}</span>`,
                        'Don\'t forget to hit the spacebar when you see an upsidown triangle!!!'
                    ];

                    // If we aren't at the end of the experiment
                    if(i + 1 !== trialseq.shape()[0]) {

                        // Adjust the deadline for the block if we have to
                        if(err_pct <= 10 && miss_pct <= 10) {
                            const currentDeadline = trialseq.get(i, settings.id.deadline);
                            const newDeadline = currentDeadline - settings.durations.deadlineAdj;
                            for(let ii = i + 1; ii < trialseq.shape()[0]; ii++) trialseq.set(ii, settings.id.deadline, Math.max(newDeadline, settings.durations.minDeadline));
                        } else if (err_pct >= 25 || miss_pct > 10) {
                            const currentDeadline = trialseq.get(i, settings.id.deadline);
                            const newDeadline = currentDeadline + settings.durations.deadlineAdj;
                            for(let ii = i + 1; ii < trialseq.shape()[0]; ii++) trialseq.set(ii, settings.id.deadline, Math.min(newDeadline, settings.durations.maxDeadline));
                        }

                    }

                    trialseq.print();

                    await Psych.blockFeedback(fb);

                }

                // Proceed to next trial
                i++;

            }

            // Calculate error percent
            const block = trialseq.getRowsAndColumnsByCriteria(row => row[settings.id.blocknum] === trialseq.get(i - 1, settings.id.blocknum));
            const err = block.getRowsAndColumnsByCriteria(row => row[settings.id.acc] === 2);
            const err_pct = err ? parseInt((err.shape()[0] / block.shape()[0]) * 100) : 0;
            const miss = block.getRowsAndColumnsByCriteria(row => row[settings.id.acc] === settings.acc.miss || row[settings.id.acc] === settings.acc.postTrialCorrect || row[settings.id.acc] === settings.acc.postTrialIncorrect)
            const miss_pct = miss ? parseInt((miss.shape()[0] / block.shape()[0]) * 100) : 0;

            // Calculate 75% quartile of MAD
            var corr;
            var rts = 0;
            var mean_absolute_deviation = 0;

            if(block) {
                corr = block.getRowsAndColumnsByCriteria(row => row[settings.id.rt] > 0);
            }

            if(corr) {
                rts = corr.getCol(settings.id.rt);
            }

            if(rts.length > 0) {
                mean_absolute_deviation = getStartingDuration(rts);
            } else {
                mean_absolute_deviation = 550;
            }

            return { err_pct, mean_absolute_deviation, miss_pct };

        }
        
        async function startScreen() {
            return new Promise((resolve) => {

                // Start button
                const button = document.createElement('button');
                button.className = 'btn btn-primary';
                button.innerText = 'Start Experiment';
                button.style.position = 'absolute';
                button.style.top = '50%';
                button.style.left = '50%';
                button.style.transform = 'translate(-50%, -50%)';

                // Connect elements
                document.getElementById('root').appendChild(button);

                // Add event listener
                button.addEventListener('click', () => {
                    console.log('Click');
                    resolve();
                })

            })
        }

        async function askShouldMoveOn() {
            return new Promise((resolve) => {

                Psych.showCursor();

                // Clear the screen
                Psych.clear();

                // Yes button
                const yesButton = document.createElement('button');
                yesButton.className = 'btn btn-success';
                yesButton.innerText = 'Move on to full experiment';
                yesButton.style.margin = '25px';

                // No button
                const noButton = document.createElement('button');
                noButton.className = 'btn btn-danger';
                noButton.innerText = 'Repeat training';
                noButton.style.margin = '25px';

                // Container
                const container = document.createElement('div');
                container.style.display = 'flex';
                container.style.justifyContent = 'center';
                container.style.alignItems = 'center';
                container.style.height = '100%';

                container.appendChild(yesButton);
                container.appendChild(noButton);
                document.getElementById('root').appendChild(container);

                yesButton.addEventListener('click', () => { Psych.hideCursor(); Psych.clear(); resolve(true) });
                noButton.addEventListener('click', () => { Psych.hideCursor(); Psych.clear(); resolve(false) });

            })
        }

        async function main() {

            // Project vars
            const project_name = 'NOF';

            // Clear the DOM
            Psych.clear();

            Psych.init();

            await startScreen();

            Psych.hideCursor();
            await Psych.fullScreen();

            // Instructions
            await instructions();

            // Generate their confirmation code / subject number
            const subject_id = uuid();

            // Create the api client
            const client = new ApiClient(subject_id, project_name, {});

            // Keep running training until they have <20% errors and misses
            var shouldMoveOn = false;
            while(!shouldMoveOn) {

                // Run training
                await experiment(client, true, 500);

                shouldMoveOn = await askShouldMoveOn();

            };

            // Run full experiment
            await experiment(client, false, 500);

            Psych.showCursor();
            await Psych.exitFullScreen();

            // Finishing screen
            await Psych.welcome({ text: `Task complete! Thank you for participating!` });

        }

        async function instructions() {

            Psych.clear();
            Psych.init();

            const dims = Psych.dims();
            const settings = Settings();

            // Flankers + target stimuli
            const target = Psych.divWithText({
                text: '<<<<<',
                letterSpacing: '3px',
                color: 'black',
                fontSize: '8em'
            }, {
                top: `${dims.height / 2}px`,
                left: `${dims.width / 2}px`,
                borderRadius: '5px',
                width: '100%',
                height: '100px',
                backgroundColor: 'transparent'
            })

            const missFeedback = Psych.divWithText({
                text: 'FASTER!',
                color: 'red',
                fontWeight: 'bold',
                letterSpacing: '1px',
                fontSize: '7em'
            }, {
                top: `${dims.height / 2}px`,
                left: `${dims.width / 2}px`,
                width: '100%',
                height: '150px',
                backgroundColor: 'transparent'
            })

            const instruction_text = Psych.divWithText({
                text: 'At the start of every trial, this is what will appear. (Press spacebar to continue)',
                letterSpacing: '3px',
                color: 'black',
                fontSize: '1.3em'
            }, {
                top: `${dims.height / 4 * 3}px`,
                left: `${dims.width / 2}px`,
                borderRadius: '5px',
                width: '80%',
                height: '100px',
                margin: 'auto',
                backgroundColor: 'transparent'
            })

            const bigCircle = Psych.makeShape('circle', {
                top: dims.height / 2,
                left: dims.width / 2,
                strokeStyle: 'red',
                fillStyle: 'transparent',
                lineWidth: 5,
                size: 200
            })

            // Oddball
            const oddball = Psych.makeShape('triangle', {
                rotate: 180,
                top: dims.height / 2,
                left: dims.width / 2,
                strokeStyle: 'black',
                fillStyle: 'transparent',
                lineWidth: 20,
                size: 300
            })

            const circle = Psych.makeShape('circle', {
                top: dims.height / 2,
                left: dims.width / 2,
                strokeStyle: 'red',
                fillStyle: 'transparent',
                lineWidth: 5,
                size: 100
            })

            // Standard event
            const triangle = Psych.makeShape('triangle', {
                top: dims.height / 2,
                left: dims.width / 2,
                strokeStyle: 'black',
                fillStyle: 'transparent',
                lineWidth: 20,
                size: 300
            })

            const screenItems = [ target, triangle, circle, bigCircle, instruction_text, oddball, missFeedback ];

            // Prepare all items
            Psych.prepare(screenItems);

            // Step 1
            Psych.display([ target, bigCircle, instruction_text ]);
            await Psych.waitForKey();

            // Step 2
            Psych.hide([ bigCircle ]);
            Psych.display([ circle ]);
            instruction_text.firstChild.innerText = 'Your job is to respond to ONLY THE MIDDLE ITEM (press spacebar to continue)';
            await Psych.waitForKey();

            // Step 3
            instruction_text.firstChild.innerText = 'If the middle item points left, respond with the "q" key (press q to continue)';
            await Psych.waitForKey(81);

            // Step 4
            target.firstChild.innerText = '<<><<';
            instruction_text.firstChild.innerText = 'However, if the middle item points right, then respond with the "p" key (press p to continue)';
            await Psych.waitForKey(80);

            // Step 5
            Psych.hide([ circle ]);
            target.firstChild.innerText = '<<<<<';
            instruction_text.firstChild.innerText = 'Practice a couple more...';
            await Psych.waitForKey(81);

            target.firstChild.innerText = '>><>>';
            await Psych.waitForKey(81);

            target.firstChild.innerText = '>>>>>';
            await Psych.waitForKey(80);

            target.firstChild.innerText = '<<><<';
            await Psych.waitForKey(80);

            target.firstChild.innerText = '>><>>';
            await Psych.waitForKey(81);

            // Talk about the "faster" feedback
            Psych.hide([ target ]);
            Psych.display([ missFeedback ]);
            instruction_text.firstChild.innerText = 'It is very important that you respond as quickly and as accurately as you can on every trial! If you do not respond quickly enough, then you will be notified with this feedback. (press spacebar to continue)'
            await Psych.waitForKey();

            // Step 6
            Psych.hide([ target, missFeedback ]);
            Psych.display([ triangle ]);
            instruction_text.firstChild.innerText = 'If you respond to the target in time then this triangle will be displayed to you. This means that your response has been confirmed... (press spacebar to continue)';
            await Psych.waitForKey();

            // Step 8
            Psych.hide([ triangle ]);
            Psych.display([ oddball ]);
            instruction_text.firstChild.innerText = 'SOMETIMES the triangle will be upsidown. You must monitor for this. When the triangle is upsidown, you must respond to it using the spacebar as quickly as possible. Use the spacebar now to respond to this triangle.';
            await Psych.waitForKey();

            // Step 9
            instruction_text.firstChild.innerText = 'Good job! You successfully responded to the upsidown triangle... (press spacebar to continue)'
            await Psych.waitForKey();

            // Step 10
            Psych.hide([ oddball ]);
            instruction_text.firstChild.innerText = 'It looks like you are getting the hang of it. Now you will complete a simulated training so that you can see what the experiment feels like in real time... (press spacebar to continue)';
            await Psych.waitForKey();

            // Step 11
            instruction_text.firstChild.innerText = 'If you complete the training without making too many mistakes, you will then move on to the real experiment. Otherwise, you will be asked to repeat the training... (press spacebar to continue)';
            await Psych.waitForKey();

            // Step 12
            instruction_text.firstChild.innerText = 'The pace of the experiment is quite fast, so be prepared to respond as quickly as you can! (press spacebar to continue)';
            await Psych.waitForKey();

            // Step 13
            instruction_text.firstChild.innerText = 'According to previous studies, workers performed pretty well (above 70% accuracy), with the average response time range 330ms ~ 410ms';
            await Psych.waitForKey();

            // Step 14
            instruction_text.firstChild.innerText = 'There will be 12 blocks in the full experiment. Each block will contain 72 trials.'
            await Psych.waitForKey();

            // Step 15
            instruction_text.firstChild.innerText = 'If you are ready to begin the training, press the spacebar.';
            await Psych.waitForKey();

            Psych.clear();

        }

        function drawLoader() {

            const loader = Psych.divWithText({
                color: '#333',
                fontSize: '1.5em',
                text: 'Loading... This may take a while...',
                fontWeight: 'bolder'
            }, {
                backgroundColor: 'transparent',
                height: '100px',
                width: '100%'
            })

            loader.firstChild.id = 'loader'

            Psych.prepare([ loader ]);
            Psych.display([ loader ]);

        }

        function updateLoader() {

            const loader = document.getElementById('loader');
            const lastNum = loader.innerText.replace('Loading', '').replace(' This may take a while...', '').length;

            if(lastNum === 3) {
                loader.innerText = 'Loading. This may take a while...';
                return
            } else {
                const dots = lastNum + 1;
                var str = '';
                for(let i = 0; i < dots; i++) {str += '.'}
                loader.innerText = 'Loading' + str + ' This may take a while...';
                return
            }

        }

        function mean(arr) {
            return (arr.reduce((a, b) => a + b, 0)) / arr.length
        }

        function mad(arr) {
            const m = mean(arr);
            const n = arr.length;
            return mean(arr.map(i => Math.abs(i - m))) / n;
        }

        function getStartingDuration(rts) {
            return mean(rts) + (2.5 * std(rts));
        }

        function std(array) {
            const n = array.length - 1
            const mean = array.reduce((a, b) => a + b) / n
            return Math.sqrt(array.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / n)
        }

        function deadlineAdj(trialseq, i, settings) {

            function deadlineAdjCheck(trialseq, i, settings) {

                // Gather the accuracies of the past 5 trials
                var acc = {
                    '1': 0,
                    '2': 0,
                    '999': 0,
                    '998': 0,
                    '997': 0
                };
                for(let ii = i; ii > i - 5; ii--) acc[trialseq.get(ii, settings.id.acc)] += 1

                const err_n_miss = acc['999'] + acc['998'] + acc['997'] + acc['2']
                const correct = acc['1']

                if(correct >= 5) {
                    return 'subtract'
                } else if (err_n_miss >= 2) {
                    return 'add'
                } else {
                    return 'none'
                }
            }

            // We must be at least 5 trials in, and not at the end of the trialseq
            if(i >= 4 && i + 1 !== trialseq.shape()[0]) {

                // Figure out if we should +5ms, -3ms or do nothing
                const action = deadlineAdjCheck(trialseq, i, settings);

                if(action !== 'none') {

                    // We got an action, so we know we're going to either +-5ms, so first get the current deadline
                    var deadline = trialseq.get(i, settings.id.deadline);

                    // Now modify it
                    deadline += action === 'add' ? 5 : -3

                    // Cut off the deadline at the minimum
                    deadline = deadline < settings.durations.minDeadline ? settings.durations.minDeadline : deadline

                    // Cut off the deadline at the maximum
                    deadline = deadline > settings.durations.maxDeadline ? settings.durations.maxDeadline : deadline

                    // Now modify the rest of the trialseq with the new deadline
                    for(let ii = i + 1; ii < trialseq.shape()[0]; ii++) trialseq.set(ii, settings.id.deadline, deadline);

                }

            }

            return trialseq;

        }

    </script>

    <script>
        
        main();

    </script>

</body>
</html>